// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/speaker_server/speaker_server.proto)

#pragma once

#include <array>
#include <cmath>
#include <functional>
#include <limits>
#include <memory>
#include <string>
#include <utility>
#include <vector>


#include "server_plugin_base.h"

#include "handle.h"

namespace mavsdk {


class ServerComponent;
class SpeakerServerImpl;

/**
 * @brief Provides handling of speaker interface
 */
class SpeakerServer : public ServerPluginBase {
public:

    /**
     * @brief Constructor. Creates the plugin for a ServerComponent instance.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto speaker_server = SpeakerServer(server_component);
     *     ```
     *
     * @param server_component The ServerComponent instance associated with this server plugin.
     */
    explicit SpeakerServer(std::shared_ptr<ServerComponent> server_component);


    /**
     * @brief Destructor (internal use only).
     */
    ~SpeakerServer() override;


    /**
     * @brief Possible feedback results for speaker respond command.
     */
    enum class SpeakerFeedback {
        Unknown, /**< @brief Unknown. */
        Ok, /**< @brief Ok. */
        Busy, /**< @brief Busy. */
        Failed, /**< @brief Failed. */
        Inprogress, /**< @brief In progress. */
        Denied, /**< @brief Denied. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::SpeakerFeedback`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::SpeakerFeedback const& speaker_feedback);

    /**
     * @brief File update type.
     */
    enum class FileUpdateType {
        None, /**< @brief Unknown file update type. */
        Add, /**< @brief File added. */
        Remove, /**< @brief File deleted. */
        Rename, /**< @brief File renamed. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::FileUpdateType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::FileUpdateType const& file_update_type);

    /**
     * @brief 
     */
    enum class PlayMode {
        None, /**< @brief None play mode. */
        SinglePlay, /**< @brief Play a audio once. */
        LoopPlay, /**< @brief Loop play a audio. */
        RealTimeSpeak, /**< @brief Real time speak play mode. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::PlayMode`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::PlayMode const& play_mode);

    /**
     * @brief 
     */
    enum class PlayStatus {
        Idle, /**< @brief Not play any audio. */
        Playing, /**< @brief Play a audio. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::PlayStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::PlayStatus const& play_status);

    /**
     * @brief Light mode type.
     */
    enum class LightMode {
        ModeUnknown, /**< @brief Unknown light mode. */
        Mode1, /**< @brief Light mode 1. */
        Mode2, /**< @brief Light mode 2. */
        Mode3, /**< @brief Light mode 3. */
        Mode4, /**< @brief Light mode 4. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::LightMode`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::LightMode const& light_mode);

    /**
     * @brief Switch on/off type.
     */
    enum class SwitchOnOff {
        Off, /**< @brief off. */
        On, /**< @brief on. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::SwitchOnOff`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::SwitchOnOff const& switch_on_off);

    /**
     * @brief 
     */
    enum class RealTimeVoiceStatus {
        VoiceOff, /**< @brief Real time voice off. */
        VoiceOn, /**< @brief Real time voice on. */
        VoiceError, /**< @brief Real time voice error. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::RealTimeVoiceStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::RealTimeVoiceStatus const& real_time_voice_status);

    /**
     * @brief Multi Connection Operation type.
     */
    enum class OperationType {
        MultiConnectionOpen, /**< @brief Connection open. */
        MultiConnectionClose, /**< @brief Connection close. */
        MultiConnectionRemove, /**< @brief Connection remove. */
        MultiConnectionAdd, /**< @brief Connection add. */
        MultiConnectionQueryAmount, /**< @brief Connection query amount. */
        MultiConnectionQueryId, /**< @brief Connection query ID. */
        MultiConnectionQueryStatus, /**< @brief Connection query status. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::OperationType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::OperationType const& operation_type);

    /**
     * @brief 
     */
    enum class FileOperationPermission {
        Release, /**< @brief Release file operation permission. */
        Get, /**< @brief Get file operation permission. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::FileOperationPermission`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::FileOperationPermission const& file_operation_permission);

    /**
     * @brief 
     */
    enum class RealTimeVoiceOperation {
        StartRealTimeListen, /**< @brief Start real time voice listen. */
        StopRealTimeListen, /**< @brief Stop real time voice listen. */
        StartRealTimeSpeak, /**< @brief Start real time voice speak. */
        StopRealTimeSpeak, /**< @brief Stop real time voice speak. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::RealTimeVoiceOperation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::RealTimeVoiceOperation const& real_time_voice_operation);

    /**
     * @brief log level
     */
    enum class LogLevel {
        Debug, /**< @brief Debug log level. */
        Info, /**< @brief Info log level. */
        Warning, /**< @brief Warning log level. */
        Error, /**< @brief Error log level. */
        Fatal, /**< @brief Fatal log level. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::LogLevel`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::LogLevel const& log_level);





    /**
     * @brief Possible results returned for action requests.
     */
    enum class Result {
        Unknown, /**< @brief Unknown result. */
        Success, /**< @brief Command executed successfully. */
        InProgress, /**< @brief Command in progress. */
        Busy, /**< @brief Speaker is busy and rejected command. */
        Denied, /**< @brief Speaker denied the command. */
        Error, /**< @brief An error has occurred while executing the command. */
        Timeout, /**< @brief Command timed out. */
        WrongArgument, /**< @brief Command has wrong argument(s). */
        NoSystem, /**< @brief No system connected. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::Result`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::Result const& result);





    /**
     * @brief 
     */
    struct Information {
        
        std::string vendor_name{}; /**< @brief Name of the speaker vendor */
        std::string model_name{}; /**< @brief Name of the speaker model */
        std::string serial_number{}; /**< @brief Serial number of the speaker */
        std::string firmware_version{}; /**< @brief Firmware version of the speaker */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::Information` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::Information& lhs, const SpeakerServer::Information& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::Information`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::Information const& information);




    /**
     * @brief 
     */
    struct PlayAudioParams {
        
        PlayMode play_mode{}; /**< @brief Play audio mode */
        uint32_t index{}; /**< @brief Index of the audio file */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::PlayAudioParams` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::PlayAudioParams& lhs, const SpeakerServer::PlayAudioParams& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::PlayAudioParams`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::PlayAudioParams const& play_audio_params);




    /**
     * @brief Information about a audio.
     */
    struct AudioInfo {
        
        std::string name{}; /**< @brief The name of audio file */
        uint32_t index{}; /**< @brief Zero-based index of this audio since vehicle was armed */
        std::string format{}; /**< @brief Audio file's format */
        float length{}; /**< @brief The length of audio (in secends) */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::AudioInfo` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::AudioInfo& lhs, const SpeakerServer::AudioInfo& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::AudioInfo`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::AudioInfo const& audio_info);




    /**
     * @brief 
     */
    struct Angle {
        
        float roll{}; /**< @brief Roll value */
        float pitch{}; /**< @brief Pitch value */
        float yaw{}; /**< @brief Yaw value */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::Angle` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::Angle& lhs, const SpeakerServer::Angle& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::Angle`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::Angle const& angle);




    /**
     * @brief 
     */
    struct Status {
        
        PlayMode play_mode{}; /**< @brief Play audio mode */
        PlayStatus play_status{}; /**< @brief Whether audio playing is currently in process */
        float playing_time_s{}; /**< @brief Elapsed time since starting the audio playing (in seconds) */
        float current_volume{}; /**< @brief Current volume level (in persentage) */
        int32_t network_module_signal_quality{}; /**< @brief Network module signal quality (in percentage) */
        float network_module_latency_ms{}; /**< @brief Network module latency (in milliseconds) */
        Angle angle{}; /**< @brief Angle value */
        LightMode light_mode{}; /**< @brief Light mode */
        SwitchOnOff light_on_off{}; /**< @brief Light on/off */
        RealTimeVoiceStatus real_time_listen_status{}; /**< @brief Real time listen status */
        RealTimeVoiceStatus real_time_speak_status{}; /**< @brief Real time speak status */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::Status` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::Status& lhs, const SpeakerServer::Status& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::Status`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::Status const& status);






    /**
     * @brief Information about the speaker storage.
     */
    struct StorageInformation {
        
        /**
     * @brief Storage status type.
     */
    enum class StorageStatus {
        NotAvailable, /**< @brief Storage not available. */
        Unformatted, /**< @brief Storage is not formatted (i.e. has no recognized file system). */
        Formatted, /**< @brief Storage is formatted (i.e. has recognized a file system). */
        NotSupported, /**< @brief Storage status is not supported. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::StorageStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::StorageInformation::StorageStatus const& storage_status);
        
        /**
     * @brief Storage type.
     */
    enum class StorageType {
        Unknown, /**< @brief Storage type unknown. */
        UsbStick, /**< @brief Storage type USB stick. */
        Sd, /**< @brief Storage type SD card. */
        Microsd, /**< @brief Storage type MicroSD card. */
        Hd, /**< @brief Storage type HD mass storage. */
        Other, /**< @brief Storage type other, not listed. */
    };

    /**
     * @brief Stream operator to print information about a `SpeakerServer::StorageType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::StorageInformation::StorageType const& storage_type);
        
        StorageStatus storage_status{}; /**< @brief Storage status */
        StorageType storage_type{}; /**< @brief Storage type */
        float total_storage_mib{}; /**< @brief Total storage (in MiB) */
        float used_storage_mib{}; /**< @brief Used storage (in MiB) */
        float available_storage_mib{}; /**< @brief Available storage (in MiB) */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::StorageInformation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::StorageInformation& lhs, const SpeakerServer::StorageInformation& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::StorageInformation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::StorageInformation const& storage_information);




    /**
     * @brief 
     */
    struct MultiConnectionOperation {
        
        OperationType operation_type{}; /**< @brief Multi connection operation type */
        uint64_t connection_id{}; /**< @brief Connection ID */
        uint32_t connection_index{}; /**< @brief Connection index */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::MultiConnectionOperation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::MultiConnectionOperation& lhs, const SpeakerServer::MultiConnectionOperation& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::MultiConnectionOperation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::MultiConnectionOperation const& multi_connection_operation);




    /**
     * @brief 
     */
    struct MultiConnectionStatus {
        
        OperationType operation_ack{}; /**< @brief Multi connection operation ack */
        uint32_t connection_amount{}; /**< @brief Connection amount */
        uint32_t connection_index{}; /**< @brief Connection index */
        uint64_t connection_id{}; /**< @brief Connection ID */
        bool connection_status{}; /**< @brief Connection status */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::MultiConnectionStatus` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::MultiConnectionStatus& lhs, const SpeakerServer::MultiConnectionStatus& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::MultiConnectionStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::MultiConnectionStatus const& multi_connection_status);




    /**
     * @brief 
     */
    struct EnterDevModeParams {
        
        uint32_t pwd_hashed{}; /**< @brief */
    };

    /**
     * @brief Equal operator to compare two `SpeakerServer::EnterDevModeParams` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const SpeakerServer::EnterDevModeParams& lhs, const SpeakerServer::EnterDevModeParams& rhs);

    /**
     * @brief Stream operator to print information about a `SpeakerServer::EnterDevModeParams`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, SpeakerServer::EnterDevModeParams const& enter_dev_mode_params);


    /**
     * @brief Callback type for asynchronous SpeakerServer calls.
     */
    using ResultCallback = std::function<void(Result)>;






    /**
     * @brief Sets the speaker information. This must be called as soon as the speaker server is created.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result set_information(Information information) const;






    /**
     * @brief Sets speaker in progress status flags. This should be set to true when the speaker is busy play a audio and false when it is done.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result set_in_progress(bool in_progress) const;




        

    /**
     * @brief Callback type for subscribe_notify_audio_file_update.
     */
    using NotifyAudioFileUpdateCallback = std::function<void(FileUpdateType)>;

    /**
     * @brief Handle type for subscribe_notify_audio_file_update.
     */
    using NotifyAudioFileUpdateHandle = Handle<FileUpdateType>;

    /**
     * @brief Subscribe to notify audio file update requests. Each request received should respond to using RespondNotifyAudioFileUpdate.
     */
    NotifyAudioFileUpdateHandle subscribe_notify_audio_file_update(const NotifyAudioFileUpdateCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_notify_audio_file_update
     */
    void unsubscribe_notify_audio_file_update(NotifyAudioFileUpdateHandle handle);

        








    /**
     * @brief Respond to an notify audio file update request from SubscribeNotifyAudioFileUpdate.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_notify_audio_file_update(SpeakerFeedback notify_audio_file_update_feedback) const;




        

    /**
     * @brief Callback type for subscribe_start_play_audio.
     */
    using StartPlayAudioCallback = std::function<void(PlayAudioParams)>;

    /**
     * @brief Handle type for subscribe_start_play_audio.
     */
    using StartPlayAudioHandle = Handle<PlayAudioParams>;

    /**
     * @brief Subscribe to start play audio requests. Each request received should respond to using RespondStartPlayAudio.
     */
    StartPlayAudioHandle subscribe_start_play_audio(const StartPlayAudioCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_start_play_audio
     */
    void unsubscribe_start_play_audio(StartPlayAudioHandle handle);

        








    /**
     * @brief Respond to an start play aduio request from SubscribeStartPlayAudio.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_start_play_audio(SpeakerFeedback start_play_audio_feedback) const;




        

    /**
     * @brief Callback type for subscribe_stop_play_audio.
     */
    using StopPlayAudioCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_stop_play_audio.
     */
    using StopPlayAudioHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to stop play audio requests. Each request received should respond to using RespondStopPlayAudio.
     */
    StopPlayAudioHandle subscribe_stop_play_audio(const StopPlayAudioCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_stop_play_audio
     */
    void unsubscribe_stop_play_audio(StopPlayAudioHandle handle);

        








    /**
     * @brief Respond to an stop play aduio request from SubscribeStopPlayAudio.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_stop_play_audio(SpeakerFeedback stop_play_audio_feedback) const;




        

    /**
     * @brief Callback type for subscribe_audio_info.
     */
    using AudioInfoCallback = std::function<void(std::string)>;

    /**
     * @brief Handle type for subscribe_audio_info.
     */
    using AudioInfoHandle = Handle<std::string>;

    /**
     * @brief Subscribe to audio info requests. Each request received should respond to using RespondAudioInfo.
     */
    AudioInfoHandle subscribe_audio_info(const AudioInfoCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_audio_info
     */
    void unsubscribe_audio_info(AudioInfoHandle handle);

        








    /**
     * @brief Respond to an audio info request from SubscribeAudioInfo.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_audio_info(AudioInfo audio_info, SpeakerFeedback audio_info_feedback) const;




        

    /**
     * @brief Callback type for subscribe_status.
     */
    using StatusCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_status.
     */
    using StatusHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to speaker status requests. Each request received should response to using RespondStatus
     */
    StatusHandle subscribe_status(const StatusCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_status
     */
    void unsubscribe_status(StatusHandle handle);

        








    /**
     * @brief Respond to speaker status from SubscribeStatus.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_status(SpeakerFeedback status_feedback, Status status) const;




        

    /**
     * @brief Callback type for subscribe_set_volume.
     */
    using SetVolumeCallback = std::function<void(uint32_t)>;

    /**
     * @brief Handle type for subscribe_set_volume.
     */
    using SetVolumeHandle = Handle<uint32_t>;

    /**
     * @brief Subscribe to set volume requests. Each request received should respond to using RespondSetVolume.
     */
    SetVolumeHandle subscribe_set_volume(const SetVolumeCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_set_volume
     */
    void unsubscribe_set_volume(SetVolumeHandle handle);

        








    /**
     * @brief Respond to an set volume request from SubscribeSetVolume.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_set_volume(SpeakerFeedback feedback) const;




        

    /**
     * @brief Callback type for subscribe_storage_information.
     */
    using StorageInformationCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_storage_information.
     */
    using StorageInformationHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to speaker storage information requests. Each request received should response to using RespondStorageInformation
     */
    StorageInformationHandle subscribe_storage_information(const StorageInformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_storage_information
     */
    void unsubscribe_storage_information(StorageInformationHandle handle);

        








    /**
     * @brief Respond to speaker storage information from SubscribeStorageInformation.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_storage_information(SpeakerFeedback storage_information_feedback, StorageInformation storage_information) const;




        

    /**
     * @brief Callback type for subscribe_information.
     */
    using InformationCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_information.
     */
    using InformationHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to speaker information requests. Each request received should response to using RespondInformation
     */
    InformationHandle subscribe_information(const InformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_information
     */
    void unsubscribe_information(InformationHandle handle);

        








    /**
     * @brief Respond to speaker information from SubscribeInformation.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_information(SpeakerFeedback information_feedback, Information information) const;




        

    /**
     * @brief Callback type for subscribe_format_storage.
     */
    using FormatStorageCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_format_storage.
     */
    using FormatStorageHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to speaker format storage requests. Each request received should response to using RespondFormatStorage
     */
    FormatStorageHandle subscribe_format_storage(const FormatStorageCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_format_storage
     */
    void unsubscribe_format_storage(FormatStorageHandle handle);

        








    /**
     * @brief Respond to speaker format storage from SubscribeFormatStorage.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_format_storage(SpeakerFeedback format_storage_feedback) const;




        

    /**
     * @brief Callback type for subscribe_reset_settings.
     */
    using ResetSettingsCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_reset_settings.
     */
    using ResetSettingsHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to reset settings requests. Each request received should response to using RespondResetSettings
     */
    ResetSettingsHandle subscribe_reset_settings(const ResetSettingsCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_reset_settings
     */
    void unsubscribe_reset_settings(ResetSettingsHandle handle);

        








    /**
     * @brief Respond to reset settings from SubscribeResetSettings.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_reset_settings(SpeakerFeedback reset_settings_feedback) const;




        

    /**
     * @brief Callback type for subscribe_update_firmware.
     */
    using UpdateFirmwareCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_update_firmware.
     */
    using UpdateFirmwareHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to update the firmware of the speaker.
     */
    UpdateFirmwareHandle subscribe_update_firmware(const UpdateFirmwareCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_update_firmware
     */
    void unsubscribe_update_firmware(UpdateFirmwareHandle handle);

        








    /**
     * @brief Respond to update the firmware of the speaker.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_update_firmware(SpeakerFeedback update_firmware_feedback) const;




        

    /**
     * @brief Callback type for subscribe_restart.
     */
    using RestartCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_restart.
     */
    using RestartHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to reset the speaker.
     */
    RestartHandle subscribe_restart(const RestartCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_restart
     */
    void unsubscribe_restart(RestartHandle handle);

        








    /**
     * @brief Respond to reset the speaker.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_restart(SpeakerFeedback reset_feedback) const;




        

    /**
     * @brief Callback type for subscribe_set_angle.
     */
    using SetAngleCallback = std::function<void(Angle)>;

    /**
     * @brief Handle type for subscribe_set_angle.
     */
    using SetAngleHandle = Handle<Angle>;

    /**
     * @brief Subscribe to request the speaker set pitch value.
     */
    SetAngleHandle subscribe_set_angle(const SetAngleCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_set_angle
     */
    void unsubscribe_set_angle(SetAngleHandle handle);

        








    /**
     * @brief Respond to request the speaker set pitch value.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_set_angle(SpeakerFeedback set_pitch_feedback) const;




        

    /**
     * @brief Callback type for subscribe_set_light_mode.
     */
    using SetLightModeCallback = std::function<void(LightMode)>;

    /**
     * @brief Handle type for subscribe_set_light_mode.
     */
    using SetLightModeHandle = Handle<LightMode>;

    /**
     * @brief Subscribe to request set the speaker light mode.
     */
    SetLightModeHandle subscribe_set_light_mode(const SetLightModeCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_set_light_mode
     */
    void unsubscribe_set_light_mode(SetLightModeHandle handle);

        








    /**
     * @brief Respond to request set the speaker light mode.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_set_light_mode(SpeakerFeedback set_light_mode_feedback) const;




        

    /**
     * @brief Callback type for subscribe_set_light_on_off.
     */
    using SetLightOnOffCallback = std::function<void(SwitchOnOff)>;

    /**
     * @brief Handle type for subscribe_set_light_on_off.
     */
    using SetLightOnOffHandle = Handle<SwitchOnOff>;

    /**
     * @brief Subscribe to request set the speaker light on/off.
     */
    SetLightOnOffHandle subscribe_set_light_on_off(const SetLightOnOffCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_set_light_on_off
     */
    void unsubscribe_set_light_on_off(SetLightOnOffHandle handle);

        








    /**
     * @brief Respond to request set the speaker light on/off.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_set_light_on_off(SpeakerFeedback set_light_on_off_feedback) const;




        

    /**
     * @brief Callback type for subscribe_follow_gimbal.
     */
    using FollowGimbalCallback = std::function<void(SwitchOnOff)>;

    /**
     * @brief Handle type for subscribe_follow_gimbal.
     */
    using FollowGimbalHandle = Handle<SwitchOnOff>;

    /**
     * @brief Subscribe to request the speaker follow the gimbal.
     */
    FollowGimbalHandle subscribe_follow_gimbal(const FollowGimbalCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_follow_gimbal
     */
    void unsubscribe_follow_gimbal(FollowGimbalHandle handle);

        








    /**
     * @brief Respond to request the speaker follow the gimbal.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_follow_gimbal(SpeakerFeedback follow_gimbal_feedback) const;




        

    /**
     * @brief Callback type for subscribe_multi_connection_operation.
     */
    using MultiConnectionOperationCallback = std::function<void(MultiConnectionOperation)>;

    /**
     * @brief Handle type for subscribe_multi_connection_operation.
     */
    using MultiConnectionOperationHandle = Handle<MultiConnectionOperation>;

    /**
     * @brief Subscribe to request the connection operation.
     */
    MultiConnectionOperationHandle subscribe_multi_connection_operation(const MultiConnectionOperationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_multi_connection_operation
     */
    void unsubscribe_multi_connection_operation(MultiConnectionOperationHandle handle);

        








    /**
     * @brief Respond to request the connection operation.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_multi_connection_operation(MultiConnectionStatus multi_connection_status, SpeakerFeedback connection_operation_feedback) const;




        

    /**
     * @brief Callback type for subscribe_apply_file_operation_permission.
     */
    using ApplyFileOperationPermissionCallback = std::function<void(FileOperationPermission)>;

    /**
     * @brief Handle type for subscribe_apply_file_operation_permission.
     */
    using ApplyFileOperationPermissionHandle = Handle<FileOperationPermission>;

    /**
     * @brief Subscribe to request the apply file operation permission.
     */
    ApplyFileOperationPermissionHandle subscribe_apply_file_operation_permission(const ApplyFileOperationPermissionCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_apply_file_operation_permission
     */
    void unsubscribe_apply_file_operation_permission(ApplyFileOperationPermissionHandle handle);

        








    /**
     * @brief Respond to request the apply file operation permission.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_apply_file_operation_permission(SpeakerFeedback apply_file_operation_permission_feedback) const;




        

    /**
     * @brief Callback type for subscribe_real_time_voice_operation.
     */
    using RealTimeVoiceOperationCallback = std::function<void(RealTimeVoiceOperation)>;

    /**
     * @brief Handle type for subscribe_real_time_voice_operation.
     */
    using RealTimeVoiceOperationHandle = Handle<RealTimeVoiceOperation>;

    /**
     * @brief Subscribe to request the speaker real time voice operation.
     */
    RealTimeVoiceOperationHandle subscribe_real_time_voice_operation(const RealTimeVoiceOperationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_real_time_voice_operation
     */
    void unsubscribe_real_time_voice_operation(RealTimeVoiceOperationHandle handle);

        








    /**
     * @brief Respond to request the speaker real time voice operation.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_real_time_voice_operation(SpeakerFeedback real_time_voice_operation_feedback) const;




        

    /**
     * @brief Callback type for subscribe_enter_dev_mode.
     */
    using EnterDevModeCallback = std::function<void(EnterDevModeParams)>;

    /**
     * @brief Handle type for subscribe_enter_dev_mode.
     */
    using EnterDevModeHandle = Handle<EnterDevModeParams>;

    /**
     * @brief Subscribe to enter developer mode requests. Each request received should respond to using RespondEnterDevMode.
     */
    EnterDevModeHandle subscribe_enter_dev_mode(const EnterDevModeCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_enter_dev_mode
     */
    void unsubscribe_enter_dev_mode(EnterDevModeHandle handle);

        








    /**
     * @brief Respond to enter developer mode request from SubscribeEnterDevMode.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_enter_dev_mode(SpeakerFeedback enter_dev_mode_feedback) const;






    /**
     * @brief 
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result send_log_information(std::string text, LogLevel log_level) const;




    /**
     * @brief Copy constructor.
     */
    SpeakerServer(const SpeakerServer& other);

    /**
     * @brief Equality operator (object is not copyable).
     */
    const SpeakerServer& operator=(const SpeakerServer&) = delete;

private:
    /** @private Underlying implementation, set at instantiation */
    std::unique_ptr<SpeakerServerImpl> _impl;
};

} // namespace mavsdk