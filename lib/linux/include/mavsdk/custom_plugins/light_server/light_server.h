// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/light_server/light_server.proto)

#pragma once

#include <array>
#include <cmath>
#include <functional>
#include <limits>
#include <memory>
#include <string>
#include <utility>
#include <vector>


#include "server_plugin_base.h"

#include "handle.h"

namespace mavsdk {


class ServerComponent;
class LightServerImpl;

/**
 * @brief Can be used to manage lights that implement the MAVLink
 * LightServer Protocol: .
 *
 * Currently only a single light_server is supported.
 * When multiple lights are supported the plugin will need to be
 * instantiated separately for every light_server
 */
class LightServer : public ServerPluginBase {
public:

    /**
     * @brief Constructor. Creates the plugin for a ServerComponent instance.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto light_server = LightServer(server_component);
     *     ```
     *
     * @param server_component The ServerComponent instance associated with this server plugin.
     */
    explicit LightServer(std::shared_ptr<ServerComponent> server_component);


    /**
     * @brief Destructor (internal use only).
     */
    ~LightServer() override;


    /**
     * @brief Possible feedback results for light respond command.
     */
    enum class LightFeedback {
        Unknown, /**< @brief Unknown. */
        Ok, /**< @brief Ok. */
        Busy, /**< @brief Busy. */
        Failed, /**< @brief Failed. */
        Inprogress, /**< @brief In progress. */
        Denied, /**< @brief Denied. */
    };

    /**
     * @brief Stream operator to print information about a `LightServer::LightFeedback`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::LightFeedback const& light_feedback);

    /**
     * @brief File update type.
     */
    enum class FileUpdateType {
        None, /**< @brief Unknown file update type. */
        Add, /**< @brief File added. */
        Remove, /**< @brief File deleted. */
        Rename, /**< @brief File renamed. */
        Modify, /**< @brief File modified. */
    };

    /**
     * @brief Stream operator to print information about a `LightServer::FileUpdateType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::FileUpdateType const& file_update_type);

    /**
     * @brief Light mode type.
     */
    enum class LightMode {
        ModeUnknown, /**< @brief Unknown light mode. */
        Mode1, /**< @brief Light mode 1. */
        Mode2, /**< @brief Light mode 2. */
        Mode3, /**< @brief Light mode 3. */
        Mode4, /**< @brief Light mode 4. */
        Mode5, /**< @brief Light mode 5. */
        Mode6, /**< @brief Light mode 6. */
        Mode7, /**< @brief Light mode 7. */
        Mode8, /**< @brief Light mode 8. */
        Mode9, /**< @brief Light mode 9. */
    };

    /**
     * @brief Stream operator to print information about a `LightServer::LightMode`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::LightMode const& light_mode);

    /**
     * @brief Switch on/off type.
     */
    enum class SwitchOnOff {
        Off, /**< @brief off. */
        On, /**< @brief on. */
    };

    /**
     * @brief Stream operator to print information about a `LightServer::SwitchOnOff`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::SwitchOnOff const& switch_on_off);





    /**
     * @brief Possible results returned for light commands
     */
    enum class Result {
        Unknown, /**< @brief Unknown result. */
        Success, /**< @brief Command executed successfully. */
        InProgress, /**< @brief Command in progress. */
        Busy, /**< @brief Light is busy and rejected command. */
        Denied, /**< @brief Light denied the command. */
        Error, /**< @brief An error has occurred while executing the command. */
        Timeout, /**< @brief Command timed out. */
        WrongArgument, /**< @brief Command has wrong argument(s). */
        NoSystem, /**< @brief No system connected. */
        ProtocolUnsupported, /**< @brief Definition file protocol not supported. */
    };

    /**
     * @brief Stream operator to print information about a `LightServer::Result`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::Result const& result);





    /**
     * @brief Type to represent a light information.
     */
    struct Information {
        
        std::string vendor_name{}; /**< @brief Name of the light vendor */
        std::string model_name{}; /**< @brief Name of the light model */
        std::string serial_number{}; /**< @brief Serial number of the light */
        std::string firmware_version{}; /**< @brief Firmware version of the light */
    };

    /**
     * @brief Equal operator to compare two `LightServer::Information` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const LightServer::Information& lhs, const LightServer::Information& rhs);

    /**
     * @brief Stream operator to print information about a `LightServer::Information`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::Information const& information);






    /**
     * @brief Information about the light storage.
     */
    struct StorageInformation {
        
        /**
     * @brief Storage status type.
     */
    enum class StorageStatus {
        NotAvailable, /**< @brief Storage not available. */
        Unformatted, /**< @brief Storage is not formatted (i.e. has no recognized file system). */
        Formatted, /**< @brief Storage is formatted (i.e. has recognized a file system). */
        NotSupported, /**< @brief Storage status is not supported. */
    };

    /**
     * @brief Stream operator to print information about a `LightServer::StorageStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::StorageInformation::StorageStatus const& storage_status);
        
        /**
     * @brief Storage type.
     */
    enum class StorageType {
        Unknown, /**< @brief Storage type unknown. */
        UsbStick, /**< @brief Storage type USB stick. */
        Sd, /**< @brief Storage type SD card. */
        Microsd, /**< @brief Storage type MicroSD card. */
        Hd, /**< @brief Storage type HD mass storage. */
        Other, /**< @brief Storage type other, not listed. */
    };

    /**
     * @brief Stream operator to print information about a `LightServer::StorageType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::StorageInformation::StorageType const& storage_type);
        
        StorageStatus storage_status{}; /**< @brief Storage status */
        StorageType storage_type{}; /**< @brief Storage type */
        float total_storage_mib{}; /**< @brief Total storage (in MiB) */
        float used_storage_mib{}; /**< @brief Used storage (in MiB) */
        float available_storage_mib{}; /**< @brief Available storage (in MiB) */
    };

    /**
     * @brief Equal operator to compare two `LightServer::StorageInformation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const LightServer::StorageInformation& lhs, const LightServer::StorageInformation& rhs);

    /**
     * @brief Stream operator to print information about a `LightServer::StorageInformation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::StorageInformation const& storage_information);




    /**
     * @brief Information about a .
     */
    struct FileInfo {
        
        std::string name{}; /**< @brief The name of  file */
        uint32_t index{}; /**< @brief Zero-based index of this  since vehicle was armed */
    };

    /**
     * @brief Equal operator to compare two `LightServer::FileInfo` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const LightServer::FileInfo& lhs, const LightServer::FileInfo& rhs);

    /**
     * @brief Stream operator to print information about a `LightServer::FileInfo`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::FileInfo const& file_info);




    /**
     * @brief 
     */
    struct ModeSetting {
        
        uint32_t light_id{}; /**< @brief Light ID */
        LightMode light_mode{}; /**< @brief Light mode */
    };

    /**
     * @brief Equal operator to compare two `LightServer::ModeSetting` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const LightServer::ModeSetting& lhs, const LightServer::ModeSetting& rhs);

    /**
     * @brief Stream operator to print information about a `LightServer::ModeSetting`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::ModeSetting const& mode_setting);




    /**
     * @brief 
     */
    struct SwitchSetting {
        
        uint32_t light_id{}; /**< @brief Light ID */
        SwitchOnOff light_on_off{}; /**< @brief Light on/off */
    };

    /**
     * @brief Equal operator to compare two `LightServer::SwitchSetting` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const LightServer::SwitchSetting& lhs, const LightServer::SwitchSetting& rhs);

    /**
     * @brief Stream operator to print information about a `LightServer::SwitchSetting`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::SwitchSetting const& switch_setting);




    /**
     * @brief 
     */
    struct EnterDevModeParams {
        
        uint32_t pwd_hashed{}; /**< @brief */
    };

    /**
     * @brief Equal operator to compare two `LightServer::EnterDevModeParams` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const LightServer::EnterDevModeParams& lhs, const LightServer::EnterDevModeParams& rhs);

    /**
     * @brief Stream operator to print information about a `LightServer::EnterDevModeParams`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::EnterDevModeParams const& enter_dev_mode_params);




    /**
     * @brief 
     */
    struct BrightnessSetting {
        
        uint32_t light_id{}; /**< @brief Light ID */
        float brightness{}; /**< @brief Brightness level (in percentage) */
    };

    /**
     * @brief Equal operator to compare two `LightServer::BrightnessSetting` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const LightServer::BrightnessSetting& lhs, const LightServer::BrightnessSetting& rhs);

    /**
     * @brief Stream operator to print information about a `LightServer::BrightnessSetting`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::BrightnessSetting const& brightness_setting);




    /**
     * @brief 
     */
    struct Status {
        
        uint32_t light_id{}; /**< @brief Light ID */
        SwitchOnOff light_on_off{}; /**< @brief Light on/off */
        LightMode light_mode{}; /**< @brief Light mode */
        float light_brightness{}; /**< @brief Current brightness level (in percentage) */
    };

    /**
     * @brief Equal operator to compare two `LightServer::Status` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const LightServer::Status& lhs, const LightServer::Status& rhs);

    /**
     * @brief Stream operator to print information about a `LightServer::Status`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, LightServer::Status const& status);


    /**
     * @brief Callback type for asynchronous LightServer calls.
     */
    using ResultCallback = std::function<void(Result)>;




        

    /**
     * @brief Callback type for subscribe_information.
     */
    using InformationCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_information.
     */
    using InformationHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to light information requests. Each request received should response to using RespondInformation
     */
    InformationHandle subscribe_information(const InformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_information
     */
    void unsubscribe_information(InformationHandle handle);

        








    /**
     * @brief Respond to light information from SubscribeInformation.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_information(LightFeedback information_feedback, Information information) const;




        

    /**
     * @brief Callback type for subscribe_storage_information.
     */
    using StorageInformationCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_storage_information.
     */
    using StorageInformationHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to light storage information requests. Each request received should response to using RespondStorageInformation
     */
    StorageInformationHandle subscribe_storage_information(const StorageInformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_storage_information
     */
    void unsubscribe_storage_information(StorageInformationHandle handle);

        








    /**
     * @brief Respond to light storage information from SubscribeStorageInformation.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_storage_information(LightFeedback storage_information_feedback, StorageInformation storage_information) const;




        

    /**
     * @brief Callback type for subscribe_file_info.
     */
    using FileInfoCallback = std::function<void(std::string)>;

    /**
     * @brief Handle type for subscribe_file_info.
     */
    using FileInfoHandle = Handle<std::string>;

    /**
     * @brief Subscribe to  info requests. Each request received should respond to using RespondFileInfo.
     */
    FileInfoHandle subscribe_file_info(const FileInfoCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_file_info
     */
    void unsubscribe_file_info(FileInfoHandle handle);

        








    /**
     * @brief Respond to an  info request from SubscribeFileInfo.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_file_info(FileInfo file_info, LightFeedback file_info_feedback) const;




        

    /**
     * @brief Callback type for subscribe_notify_file_update.
     */
    using NotifyFileUpdateCallback = std::function<void(FileUpdateType)>;

    /**
     * @brief Handle type for subscribe_notify_file_update.
     */
    using NotifyFileUpdateHandle = Handle<FileUpdateType>;

    /**
     * @brief Subscribe to notify  file update requests. Each request received should respond to using RespondNotifyFileUpdate.
     */
    NotifyFileUpdateHandle subscribe_notify_file_update(const NotifyFileUpdateCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_notify_file_update
     */
    void unsubscribe_notify_file_update(NotifyFileUpdateHandle handle);

        








    /**
     * @brief Respond to an notify  file update request from SubscribeNotifyFileUpdate.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_notify_file_update(LightFeedback notify_file_update_feedback) const;




        

    /**
     * @brief Callback type for subscribe_update_firmware.
     */
    using UpdateFirmwareCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_update_firmware.
     */
    using UpdateFirmwareHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to update the firmware of the light.
     */
    UpdateFirmwareHandle subscribe_update_firmware(const UpdateFirmwareCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_update_firmware
     */
    void unsubscribe_update_firmware(UpdateFirmwareHandle handle);

        








    /**
     * @brief Respond to update the firmware of the light.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_update_firmware(LightFeedback update_firmware_feedback) const;




        

    /**
     * @brief Callback type for subscribe_restart.
     */
    using RestartCallback = std::function<void(int32_t)>;

    /**
     * @brief Handle type for subscribe_restart.
     */
    using RestartHandle = Handle<int32_t>;

    /**
     * @brief Subscribe to reset the light.
     */
    RestartHandle subscribe_restart(const RestartCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_restart
     */
    void unsubscribe_restart(RestartHandle handle);

        








    /**
     * @brief Respond to reset the light.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_restart(LightFeedback reset_feedback) const;




        

    /**
     * @brief Callback type for subscribe_set_light_mode.
     */
    using SetLightModeCallback = std::function<void(ModeSetting)>;

    /**
     * @brief Handle type for subscribe_set_light_mode.
     */
    using SetLightModeHandle = Handle<ModeSetting>;

    /**
     * @brief Subscribe to request set the light light mode.
     */
    SetLightModeHandle subscribe_set_light_mode(const SetLightModeCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_set_light_mode
     */
    void unsubscribe_set_light_mode(SetLightModeHandle handle);

        








    /**
     * @brief Respond to request set the light light mode.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_set_light_mode(LightFeedback set_light_mode_feedback) const;




        

    /**
     * @brief Callback type for subscribe_set_light_on_off.
     */
    using SetLightOnOffCallback = std::function<void(SwitchSetting)>;

    /**
     * @brief Handle type for subscribe_set_light_on_off.
     */
    using SetLightOnOffHandle = Handle<SwitchSetting>;

    /**
     * @brief Subscribe to request set the light light on/off.
     */
    SetLightOnOffHandle subscribe_set_light_on_off(const SetLightOnOffCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_set_light_on_off
     */
    void unsubscribe_set_light_on_off(SetLightOnOffHandle handle);

        








    /**
     * @brief Respond to request set the light light on/off.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_set_light_on_off(LightFeedback set_light_on_off_feedback) const;




        

    /**
     * @brief Callback type for subscribe_enter_dev_mode.
     */
    using EnterDevModeCallback = std::function<void(EnterDevModeParams)>;

    /**
     * @brief Handle type for subscribe_enter_dev_mode.
     */
    using EnterDevModeHandle = Handle<EnterDevModeParams>;

    /**
     * @brief Subscribe to enter developer mode requests. Each request received should respond to using RespondEnterDevMode.
     */
    EnterDevModeHandle subscribe_enter_dev_mode(const EnterDevModeCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_enter_dev_mode
     */
    void unsubscribe_enter_dev_mode(EnterDevModeHandle handle);

        








    /**
     * @brief Respond to enter developer mode request from SubscribeEnterDevMode.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_enter_dev_mode(LightFeedback enter_dev_mode_feedback) const;




        

    /**
     * @brief Callback type for subscribe_set_light_brightness.
     */
    using SetLightBrightnessCallback = std::function<void(BrightnessSetting)>;

    /**
     * @brief Handle type for subscribe_set_light_brightness.
     */
    using SetLightBrightnessHandle = Handle<BrightnessSetting>;

    /**
     * @brief Sbuscribe to set light brightness requests. Each request received should respond to using RespondSetLightBrightness.
     */
    SetLightBrightnessHandle subscribe_set_light_brightness(const SetLightBrightnessCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_set_light_brightness
     */
    void unsubscribe_set_light_brightness(SetLightBrightnessHandle handle);

        








    /**
     * @brief Respond to set light brightness request from SubscribeSetLightBrightness.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_set_light_brightness(LightFeedback set_light_brightness_feedback) const;




        

    /**
     * @brief Callback type for subscribe_status.
     */
    using StatusCallback = std::function<void(uint32_t)>;

    /**
     * @brief Handle type for subscribe_status.
     */
    using StatusHandle = Handle<uint32_t>;

    /**
     * @brief Subscribe to light status. Each request received should respond to using RespondStatus.
     */
    StatusHandle subscribe_status(const StatusCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_status
     */
    void unsubscribe_status(StatusHandle handle);

        








    /**
     * @brief Respond to light status request from SubscribeStatus.
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result respond_status(Status status, LightFeedback status_feedback) const;




    /**
     * @brief Copy constructor.
     */
    LightServer(const LightServer& other);

    /**
     * @brief Equality operator (object is not copyable).
     */
    const LightServer& operator=(const LightServer&) = delete;

private:
    /** @private Underlying implementation, set at instantiation */
    std::unique_ptr<LightServerImpl> _impl;
};

} // namespace mavsdk