// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/light/light.proto)

#pragma once

#include <array>
#include <cmath>
#include <functional>
#include <limits>
#include <memory>
#include <string>
#include <utility>
#include <vector>


#include "plugin_base.h"

#include "handle.h"

namespace mavsdk {


class System;class LightImpl;

/**
 * @brief Can be used to manage lights that implement the MAVLink
 * Light Protocol: .
 *
 * Currently only a single light is supported.
 * When multiple lights are supported the plugin will need to be
 * instantiated separately for every light
 */
class Light : public PluginBase {
public:

    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto light = Light(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit Light(System& system); // deprecated

    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto light = Light(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit Light(std::shared_ptr<System> system); // new


    /**
     * @brief Destructor (internal use only).
     */
    ~Light() override;


    /**
     * @brief File update type.
     */
    enum class FileUpdateType {
        None, /**< @brief Unknown file update type. */
        Add, /**< @brief File added. */
        Remove, /**< @brief File deleted. */
        Rename, /**< @brief File renamed. */
        Modify, /**< @brief File modified. */
    };

    /**
     * @brief Stream operator to print information about a `Light::FileUpdateType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::FileUpdateType const& file_update_type);

    /**
     * @brief Light mode type.
     */
    enum class LightMode {
        ModeUnknown, /**< @brief Unknown light mode. */
        Mode1, /**< @brief Light mode 1. */
        Mode2, /**< @brief Light mode 2. */
        Mode3, /**< @brief Light mode 3. */
        Mode4, /**< @brief Light mode 4. */
        Mode5, /**< @brief Light mode 5. */
        Mode6, /**< @brief Light mode 6. */
        Mode7, /**< @brief Light mode 7. */
        Mode8, /**< @brief Light mode 8. */
        Mode9, /**< @brief Light mode 9. */
    };

    /**
     * @brief Stream operator to print information about a `Light::LightMode`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::LightMode const& light_mode);

    /**
     * @brief Switch on/off type.
     */
    enum class SwitchOnOff {
        Off, /**< @brief off. */
        On, /**< @brief on. */
    };

    /**
     * @brief Stream operator to print information about a `Light::SwitchOnOff`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::SwitchOnOff const& switch_on_off);





    /**
     * @brief Possible results returned for light commands
     */
    enum class Result {
        Unknown, /**< @brief Unknown result. */
        Success, /**< @brief Command executed successfully. */
        InProgress, /**< @brief Command in progress. */
        Busy, /**< @brief Light is busy and rejected command. */
        Denied, /**< @brief Light denied the command. */
        Error, /**< @brief An error has occurred while executing the command. */
        Timeout, /**< @brief Command timed out. */
        WrongArgument, /**< @brief Command has wrong argument(s). */
        NoSystem, /**< @brief No system connected. */
        ProtocolUnsupported, /**< @brief Definition file protocol not supported. */
    };

    /**
     * @brief Stream operator to print information about a `Light::Result`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::Result const& result);





    /**
     * @brief Type to represent a light information.
     */
    struct Information {
        
        std::string vendor_name{}; /**< @brief Name of the light vendor */
        std::string model_name{}; /**< @brief Name of the light model */
        std::string serial_number{}; /**< @brief Serial number of the light */
        std::string firmware_version{}; /**< @brief Firmware version of the light */
    };

    /**
     * @brief Equal operator to compare two `Light::Information` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Light::Information& lhs, const Light::Information& rhs);

    /**
     * @brief Stream operator to print information about a `Light::Information`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::Information const& information);






    /**
     * @brief Information about the light storage.
     */
    struct StorageInformation {
        
        /**
     * @brief Storage status type.
     */
    enum class StorageStatus {
        NotAvailable, /**< @brief Storage not available. */
        Unformatted, /**< @brief Storage is not formatted (i.e. has no recognized file system). */
        Formatted, /**< @brief Storage is formatted (i.e. has recognized a file system). */
        NotSupported, /**< @brief Storage status is not supported. */
    };

    /**
     * @brief Stream operator to print information about a `Light::StorageStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::StorageInformation::StorageStatus const& storage_status);
        
        /**
     * @brief Storage type.
     */
    enum class StorageType {
        Unknown, /**< @brief Storage type unknown. */
        UsbStick, /**< @brief Storage type USB stick. */
        Sd, /**< @brief Storage type SD card. */
        Microsd, /**< @brief Storage type MicroSD card. */
        Hd, /**< @brief Storage type HD mass storage. */
        Other, /**< @brief Storage type other, not listed. */
    };

    /**
     * @brief Stream operator to print information about a `Light::StorageType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::StorageInformation::StorageType const& storage_type);
        
        StorageStatus storage_status{}; /**< @brief Storage status */
        StorageType storage_type{}; /**< @brief Storage type */
        float total_storage_mib{}; /**< @brief Total storage (in MiB) */
        float used_storage_mib{}; /**< @brief Used storage (in MiB) */
        float available_storage_mib{}; /**< @brief Available storage (in MiB) */
    };

    /**
     * @brief Equal operator to compare two `Light::StorageInformation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Light::StorageInformation& lhs, const Light::StorageInformation& rhs);

    /**
     * @brief Stream operator to print information about a `Light::StorageInformation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::StorageInformation const& storage_information);




    /**
     * @brief Information about a .
     */
    struct FileInfo {
        
        std::string name{}; /**< @brief The name of file */
        uint32_t index{}; /**< @brief The index of file */
    };

    /**
     * @brief Equal operator to compare two `Light::FileInfo` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Light::FileInfo& lhs, const Light::FileInfo& rhs);

    /**
     * @brief Stream operator to print information about a `Light::FileInfo`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::FileInfo const& file_info);




    /**
     * @brief 
     */
    struct NotifyFileOperation {
        
        FileUpdateType update_type{}; /**< @brief file update type */
        uint32_t index{}; /**< @brief index of the file */
    };

    /**
     * @brief Equal operator to compare two `Light::NotifyFileOperation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Light::NotifyFileOperation& lhs, const Light::NotifyFileOperation& rhs);

    /**
     * @brief Stream operator to print information about a `Light::NotifyFileOperation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::NotifyFileOperation const& notify_file_operation);




    /**
     * @brief 
     */
    struct Status {
        
        uint32_t light_id{}; /**< @brief Light ID */
        SwitchOnOff light_on_off{}; /**< @brief Light on/off */
        LightMode light_mode{}; /**< @brief Light mode */
        float light_brightness{}; /**< @brief Current brightness level (in percentage) */
    };

    /**
     * @brief Equal operator to compare two `Light::Status` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Light::Status& lhs, const Light::Status& rhs);

    /**
     * @brief Stream operator to print information about a `Light::Status`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Light::Status const& status);


    /**
     * @brief Callback type for asynchronous Light calls.
     */
    using ResultCallback = std::function<void(Result)>;




    /**
     * @brief Prepare the light plugin (e.g. download the light definition, etc).
     *
     * This function is non-blocking. See 'prepare' for the blocking counterpart.
     */
    void prepare_async(const ResultCallback callback);



    /**
     * @brief Prepare the light plugin (e.g. download the light definition, etc).
     *
     * This function is blocking. See 'prepare_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result prepare() const;




        

    /**
     * @brief Callback type for subscribe_information.
     */
    using InformationCallback = std::function<void(Information)>;

    /**
     * @brief Handle type for subscribe_information.
     */
    using InformationHandle = Handle<Information>;

    /**
     * @brief Subscribe to light information updates.
     */
    InformationHandle subscribe_information(const InformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_information
     */
    void unsubscribe_information(InformationHandle handle);

        



    /**
     * @brief Poll for 'Information' (blocking).
     *
     * @return One Information update.
     */
    Information information() const;




        

    /**
     * @brief Callback type for subscribe_storage_information.
     */
    using StorageInformationCallback = std::function<void(StorageInformation)>;

    /**
     * @brief Handle type for subscribe_storage_information.
     */
    using StorageInformationHandle = Handle<StorageInformation>;

    /**
     * @brief Subscribe to light status updates.
     */
    StorageInformationHandle subscribe_storage_information(const StorageInformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_storage_information
     */
    void unsubscribe_storage_information(StorageInformationHandle handle);

        



    /**
     * @brief Poll for 'StorageInformation' (blocking).
     *
     * @return One StorageInformation update.
     */
    StorageInformation storage_information() const;




        

    /**
     * @brief Callback type for subscribe_file_info.
     */
    using FileInfoCallback = std::function<void(FileInfo)>;

    /**
     * @brief Handle type for subscribe_file_info.
     */
    using FileInfoHandle = Handle<FileInfo>;

    /**
     * @brief Subscribe to  file information.
     */
    FileInfoHandle subscribe_file_info(std::string file_name, const FileInfoCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_file_info
     */
    void unsubscribe_file_info(FileInfoHandle handle);

        



    /**
     * @brief Poll for 'FileInfo' (blocking).
     *
     * @return One FileInfo update.
     */
    FileInfo file_info(std::string file_name) const;




    /**
     * @brief Notify files updated.
     *
     * This function is non-blocking. See 'notify_file_update' for the blocking counterpart.
     */
    void notify_file_update_async(NotifyFileOperation file_operation, const ResultCallback callback);



    /**
     * @brief Notify files updated.
     *
     * This function is blocking. See 'notify_file_update_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result notify_file_update(NotifyFileOperation file_operation) const;




    /**
     * @brief Update the firmware of the light.
     *
     * This function is non-blocking. See 'update_firmware' for the blocking counterpart.
     */
    void update_firmware_async(const ResultCallback callback);



    /**
     * @brief Update the firmware of the light.
     *
     * This function is blocking. See 'update_firmware_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result update_firmware() const;




    /**
     * @brief Restart the light plugin.
     *
     * This function is non-blocking. See 'restart' for the blocking counterpart.
     */
    void restart_async(const ResultCallback callback);



    /**
     * @brief Restart the light plugin.
     *
     * This function is blocking. See 'restart_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result restart() const;




    /**
     * @brief Set light mode.
     *
     * This function is non-blocking. See 'set_light_mode' for the blocking counterpart.
     */
    void set_light_mode_async(uint32_t light_id, LightMode light_mode, const ResultCallback callback);



    /**
     * @brief Set light mode.
     *
     * This function is blocking. See 'set_light_mode_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_light_mode(uint32_t light_id, LightMode light_mode) const;




    /**
     * @brief Turn on/off light.
     *
     * This function is non-blocking. See 'set_light_on_off' for the blocking counterpart.
     */
    void set_light_on_off_async(uint32_t light_id, SwitchOnOff light_on_off, const ResultCallback callback);



    /**
     * @brief Turn on/off light.
     *
     * This function is blocking. See 'set_light_on_off_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_light_on_off(uint32_t light_id, SwitchOnOff light_on_off) const;




    /**
     * @brief Enter developer mode
     *
     * This function is non-blocking. See 'enter_dev_mode' for the blocking counterpart.
     */
    void enter_dev_mode_async(std::string pwd, const ResultCallback callback);



    /**
     * @brief Enter developer mode
     *
     * This function is blocking. See 'enter_dev_mode_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result enter_dev_mode(std::string pwd) const;




    /**
     * @brief * Set light brightness.
     *
     * This function is non-blocking. See 'set_light_brightness' for the blocking counterpart.
     */
    void set_light_brightness_async(uint32_t light_id, float brightness, const ResultCallback callback);



    /**
     * @brief * Set light brightness.
     *
     * This function is blocking. See 'set_light_brightness_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_light_brightness(uint32_t light_id, float brightness) const;




        

    /**
     * @brief Callback type for subscribe_status.
     */
    using StatusCallback = std::function<void(Status)>;

    /**
     * @brief Handle type for subscribe_status.
     */
    using StatusHandle = Handle<Status>;

    /**
     * @brief Subscribe to light status updates.
     */
    StatusHandle subscribe_status(uint32_t light_id, const StatusCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_status
     */
    void unsubscribe_status(StatusHandle handle);

        



    /**
     * @brief Poll for 'Status' (blocking).
     *
     * @return One Status update.
     */
    Status status(uint32_t light_id) const;




    /**
     * @brief Copy constructor.
     */
    Light(const Light& other);

    /**
     * @brief Equality operator (object is not copyable).
     */
    const Light& operator=(const Light&) = delete;

private:
    /** @private Underlying implementation, set at instantiation */
    std::unique_ptr<LightImpl> _impl;
};

} // namespace mavsdk