// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/custom_motor/custom_motor.proto)

#pragma once

#include <array>
#include <cmath>
#include <functional>
#include <limits>
#include <memory>
#include <string>
#include <utility>
#include <vector>


#include "plugin_base.h"

#include "handle.h"

namespace mavsdk {


class System;class CustomMotorImpl;

/**
 * @brief This service can be used to manage the MAVLink motor protocol.
 */
class CustomMotor : public PluginBase {
public:

    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto custom_motor = CustomMotor(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit CustomMotor(System& system); // deprecated

    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto custom_motor = CustomMotor(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit CustomMotor(std::shared_ptr<System> system); // new


    /**
     * @brief Destructor (internal use only).
     */
    ~CustomMotor() override;


    /**
     * @brief 
     */
    enum class MotorEnable {
        MotorDisable, /**< @brief. */
        MotorEnbale, /**< @brief. */
    };

    /**
     * @brief Stream operator to print information about a `CustomMotor::MotorEnable`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::MotorEnable const& motor_enable);

    /**
     * @brief 
     */
    enum class MotorForceReverse {
        ForceNotReverse, /**< @brief. */
        ForceReverse, /**< @brief. */
    };

    /**
     * @brief Stream operator to print information about a `CustomMotor::MotorForceReverse`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::MotorForceReverse const& motor_force_reverse);

    /**
     * @brief 
     */
    enum class MotorAngleReverse {
        AngleNotReverse, /**< @brief. */
        AngleReverse, /**< @brief. */
    };

    /**
     * @brief Stream operator to print information about a `CustomMotor::MotorAngleReverse`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::MotorAngleReverse const& motor_angle_reverse);

    /**
     * @brief 
     */
    enum class MotorLineReverse {
        LineNotReverse, /**< @brief. */
        LineReverse, /**< @brief. */
    };

    /**
     * @brief Stream operator to print information about a `CustomMotor::MotorLineReverse`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::MotorLineReverse const& motor_line_reverse);

    /**
     * @brief 
     */
    enum class ControlParamType {
        ParamNull, /**< @brief. */
        AnglePid, /**< @brief 3 float parameters. */
        VelocityPid, /**< @brief 3 float parameters. */
        CurrentPid, /**< @brief 3 uint16_t parameters. */
        MaxTorqueCurrent, /**< @brief 1 int16_t parameter. */
        MaxSpeed, /**< @brief 1 int32_t parameter. */
        AngleLimit, /**< @brief 1 int32_t parameter. */
        CurrentSlope, /**< @brief 1 int32_t parameter. */
        SpeedSlope, /**< @brief 1 int32_t parameter. */
        MotorCalibration, /**< @brief 6 float parameters. */
    };

    /**
     * @brief Stream operator to print information about a `CustomMotor::ControlParamType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::ControlParamType const& control_param_type);

    /**
     * @brief 
     */
    enum class SpinDirection {
        Null, /**< @brief. */
        Cw, /**< @brief. */
        Ccw, /**< @brief. */
    };

    /**
     * @brief Stream operator to print information about a `CustomMotor::SpinDirection`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::SpinDirection const& spin_direction);




    /**
     * @brief 
     */
    struct MotorId {
        
        uint32_t sys_id{}; /**< @brief */
        uint32_t comp_id{}; /**< @brief */
    };

    /**
     * @brief Equal operator to compare two `CustomMotor::MotorId` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomMotor::MotorId& lhs, const CustomMotor::MotorId& rhs);

    /**
     * @brief Stream operator to print information about a `CustomMotor::MotorId`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::MotorId const& motor_id);




    /**
     * @brief 
     */
    struct EncodePosition {
        
        uint32_t encoder_position{}; /**< @brief Encoder position (uint16_t), raw encoder position minus offset */
        uint32_t encoder_raw{}; /**< @brief Raw encoder position (uint16_t) */
        uint32_t encoder_offset{}; /**< @brief Encoder offset (uint16_t), initial zero after power-on */
    };

    /**
     * @brief Equal operator to compare two `CustomMotor::EncodePosition` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomMotor::EncodePosition& lhs, const CustomMotor::EncodePosition& rhs);

    /**
     * @brief Stream operator to print information about a `CustomMotor::EncodePosition`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::EncodePosition const& encode_position);




    /**
     * @brief 
     */
    struct ControlParamInformation {
        
        float param1{}; /**< @brief */
        float param2{}; /**< @brief */
        float param3{}; /**< @brief */
        float param4{}; /**< @brief */
        float param5{}; /**< @brief */
        float param6{}; /**< @brief */
        uint32_t control_param_id{}; /**< @brief */
    };

    /**
     * @brief Equal operator to compare two `CustomMotor::ControlParamInformation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomMotor::ControlParamInformation& lhs, const CustomMotor::ControlParamInformation& rhs);

    /**
     * @brief Stream operator to print information about a `CustomMotor::ControlParamInformation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::ControlParamInformation const& control_param_information);




    /**
     * @brief 
     */
    struct MotorStatusThree {
        
        float motor_temperature{}; /**< @brief Unit: 1°C */
        float phase_current_a{}; /**< @brief MG: 66/4096 A/LSB, MF: 33/4096 A/LSB */
        float phase_current_b{}; /**< @brief */
        float phase_current_c{}; /**< @brief */
    };

    /**
     * @brief Equal operator to compare two `CustomMotor::MotorStatusThree` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomMotor::MotorStatusThree& lhs, const CustomMotor::MotorStatusThree& rhs);

    /**
     * @brief Stream operator to print information about a `CustomMotor::MotorStatusThree`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::MotorStatusThree const& motor_status_three);




    /**
     * @brief 
     */
    struct MotorStatusTwo {
        
        float motor_temperature{}; /**< @brief Unit: 1°C */
        float torque_current{}; /**< @brief MG: 66/4096 A/LSB, MF: 33/4096 A/LSB */
        float output_power{}; /**< @brief Range: -1000~1000 */
        float motor_speed{}; /**< @brief Unit: 1dps/LSB */
        float motor_angle{}; /**< @briefMotor angle */
        uint32_t encoder_position{}; /**< @brief */
    };

    /**
     * @brief Equal operator to compare two `CustomMotor::MotorStatusTwo` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomMotor::MotorStatusTwo& lhs, const CustomMotor::MotorStatusTwo& rhs);

    /**
     * @brief Stream operator to print information about a `CustomMotor::MotorStatusTwo`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::MotorStatusTwo const& motor_status_two);




    /**
     * @brief 
     */
    struct MotorStatusOne {
        
        float bus_voltage{}; /**< @brief Unit: 0.01V/LSB */
        float bus_current{}; /**< @brief Unit: 0.01A/LSB */
        float motor_temperature{}; /**< @brief Unit: 1°C/LSB */
        uint32_t motor_status{}; /**< @brief See MOTOR_STATUS */
        uint32_t error_status{}; /**< @brief See MOTOR_ERR_STATUS */
    };

    /**
     * @brief Equal operator to compare two `CustomMotor::MotorStatusOne` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomMotor::MotorStatusOne& lhs, const CustomMotor::MotorStatusOne& rhs);

    /**
     * @brief Stream operator to print information about a `CustomMotor::MotorStatusOne`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::MotorStatusOne const& motor_status_one);





    /**
     * @brief 
     */
    enum class Result {
        Unknown, /**< @brief. */
        Success, /**< @brief. */
        InProgress, /**< @brief. */
        Busy, /**< @brief. */
        Denied, /**< @brief. */
        Error, /**< @brief. */
        Timeout, /**< @brief. */
        WrongArgument, /**< @brief. */
        NoSystem, /**< @brief. */
        ProtocolUnsupported, /**< @brief. */
    };

    /**
     * @brief Stream operator to print information about a `CustomMotor::Result`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomMotor::Result const& result);



    /**
     * @brief Callback type for asynchronous CustomMotor calls.
     */
    using ResultCallback = std::function<void(Result)>;




    /**
     * @brief Prepare the motor plugin (e.g. download the custom_motor definition, etc).
     *
     * This function is non-blocking. See 'prepare' for the blocking counterpart.
     */
    void prepare_async(const ResultCallback callback);



    /**
     * @brief Prepare the motor plugin (e.g. download the custom_motor definition, etc).
     *
     * This function is blocking. See 'prepare_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result prepare() const;




        

    /**
     * @brief Callback type for subscribe_motor_status_one.
     */
    using MotorStatusOneCallback = std::function<void(MotorStatusOne)>;

    /**
     * @brief Handle type for subscribe_motor_status_one.
     */
    using MotorStatusOneHandle = Handle<MotorStatusOne>;

    /**
     * @brief Subscribe to motor status 1 and error flags
     */
    MotorStatusOneHandle subscribe_motor_status_one(const MotorStatusOneCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_motor_status_one
     */
    void unsubscribe_motor_status_one(MotorStatusOneHandle handle);

        



    /**
     * @brief Poll for 'MotorStatusOne' (blocking).
     *
     * @return One MotorStatusOne update.
     */
    MotorStatusOne motor_status_one() const;




    /**
     * @brief update motor sys id
     *
     * This function is non-blocking. See 'set_sys_id' for the blocking counterpart.
     */
    void set_sys_id_async(uint32_t sys_id, const ResultCallback callback);



    /**
     * @brief update motor sys id
     *
     * This function is blocking. See 'set_sys_id_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_sys_id(uint32_t sys_id) const;




    /**
     * @brief update motor comp  id
     *
     * This function is non-blocking. See 'set_comp_id' for the blocking counterpart.
     */
    void set_comp_id_async(uint32_t comp_id, const ResultCallback callback);



    /**
     * @brief update motor comp  id
     *
     * This function is blocking. See 'set_comp_id_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_comp_id(uint32_t comp_id) const;




        

    /**
     * @brief Callback type for subscribe_motor_id.
     */
    using MotorIdCallback = std::function<void(MotorId)>;

    /**
     * @brief Handle type for subscribe_motor_id.
     */
    using MotorIdHandle = Handle<MotorId>;

    /**
     * @brief Subscribe to motor sysid and CompId
     */
    MotorIdHandle subscribe_motor_id(const MotorIdCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_motor_id
     */
    void unsubscribe_motor_id(MotorIdHandle handle);

        



    /**
     * @brief Poll for 'MotorId' (blocking).
     *
     * @return One MotorId update.
     */
    MotorId motor_id() const;




    /**
     * @brief Clear motor error flags
     *
     * This function is non-blocking. See 'clear_err_flag' for the blocking counterpart.
     */
    void clear_err_flag_async(const ResultCallback callback);



    /**
     * @brief Clear motor error flags
     *
     * This function is blocking. See 'clear_err_flag_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result clear_err_flag() const;




        

    /**
     * @brief Callback type for subscribe_motor_status_two.
     */
    using MotorStatusTwoCallback = std::function<void(MotorStatusTwo)>;

    /**
     * @brief Handle type for subscribe_motor_status_two.
     */
    using MotorStatusTwoHandle = Handle<MotorStatusTwo>;

    /**
     * @brief Subscribe to motor status 2
     */
    MotorStatusTwoHandle subscribe_motor_status_two(const MotorStatusTwoCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_motor_status_two
     */
    void unsubscribe_motor_status_two(MotorStatusTwoHandle handle);

        



    /**
     * @brief Poll for 'MotorStatusTwo' (blocking).
     *
     * @return One MotorStatusTwo update.
     */
    MotorStatusTwo motor_status_two() const;




        

    /**
     * @brief Callback type for subscribe_motor_status_three.
     */
    using MotorStatusThreeCallback = std::function<void(MotorStatusThree)>;

    /**
     * @brief Handle type for subscribe_motor_status_three.
     */
    using MotorStatusThreeHandle = Handle<MotorStatusThree>;

    /**
     * @brief Subscribe to motor status 3
     */
    MotorStatusThreeHandle subscribe_motor_status_three(const MotorStatusThreeCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_motor_status_three
     */
    void unsubscribe_motor_status_three(MotorStatusThreeHandle handle);

        



    /**
     * @brief Poll for 'MotorStatusThree' (blocking).
     *
     * @return One MotorStatusThree update.
     */
    MotorStatusThree motor_status_three() const;




    /**
     * @brief Close motor
     *
     * This function is non-blocking. See 'close_motor' for the blocking counterpart.
     */
    void close_motor_async(const ResultCallback callback);



    /**
     * @brief Close motor
     *
     * This function is blocking. See 'close_motor_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result close_motor() const;




    /**
     * @brief Open motor
     *
     * This function is non-blocking. See 'open_motor' for the blocking counterpart.
     */
    void open_motor_async(const ResultCallback callback);



    /**
     * @brief Open motor
     *
     * This function is blocking. See 'open_motor_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result open_motor() const;




    /**
     * @brief Stop motor
     *
     * This function is non-blocking. See 'stop_motor' for the blocking counterpart.
     */
    void stop_motor_async(const ResultCallback callback);



    /**
     * @brief Stop motor
     *
     * This function is blocking. See 'stop_motor_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result stop_motor() const;




    /**
     * @brief Open-loop control command
     *
     * This function is non-blocking. See 'open_loop_control' for the blocking counterpart.
     */
    void open_loop_control_async(float power_control, const ResultCallback callback);



    /**
     * @brief Open-loop control command
     *
     * This function is blocking. See 'open_loop_control_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result open_loop_control(float power_control) const;




    /**
     * @brief Torque closed-loop control
     *
     * This function is non-blocking. See 'torque_closed_loop_control' for the blocking counterpart.
     */
    void torque_closed_loop_control_async(float iq_control, const ResultCallback callback);



    /**
     * @brief Torque closed-loop control
     *
     * This function is blocking. See 'torque_closed_loop_control_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result torque_closed_loop_control(float iq_control) const;




    /**
     * @brief Speed closed-loop control
     *
     * This function is non-blocking. See 'speed_closed_loop_control' for the blocking counterpart.
     */
    void speed_closed_loop_control_async(float speed_control, const ResultCallback callback);



    /**
     * @brief Speed closed-loop control
     *
     * This function is blocking. See 'speed_closed_loop_control_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result speed_closed_loop_control(float speed_control) const;




    /**
     * @brief Multi-turn position closed-loop control 1
     *
     * This function is non-blocking. See 'multi_turn_position_closed_loop_control' for the blocking counterpart.
     */
    void multi_turn_position_closed_loop_control_async(float angle_control, const ResultCallback callback);



    /**
     * @brief Multi-turn position closed-loop control 1
     *
     * This function is blocking. See 'multi_turn_position_closed_loop_control_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result multi_turn_position_closed_loop_control(float angle_control) const;




    /**
     * @brief Multi-turn position closed-loop control 2
     *
     * This function is non-blocking. See 'multi_turn_position_closed_loop_control_two' for the blocking counterpart.
     */
    void multi_turn_position_closed_loop_control_two_async(float angle_control, float max_speed, const ResultCallback callback);



    /**
     * @brief Multi-turn position closed-loop control 2
     *
     * This function is blocking. See 'multi_turn_position_closed_loop_control_two_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result multi_turn_position_closed_loop_control_two(float angle_control, float max_speed) const;




    /**
     * @brief Single-turn position closed-loop control 1
     *
     * This function is non-blocking. See 'single_turn_position_closed_loop_control' for the blocking counterpart.
     */
    void single_turn_position_closed_loop_control_async(SpinDirection direction, float angle_control, const ResultCallback callback);



    /**
     * @brief Single-turn position closed-loop control 1
     *
     * This function is blocking. See 'single_turn_position_closed_loop_control_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result single_turn_position_closed_loop_control(SpinDirection direction, float angle_control) const;




    /**
     * @brief Single-turn position closed-loop control 2
     *
     * This function is non-blocking. See 'single_turn_position_closed_loop_control_two' for the blocking counterpart.
     */
    void single_turn_position_closed_loop_control_two_async(SpinDirection direction, float angle_control, float max_speed, const ResultCallback callback);



    /**
     * @brief Single-turn position closed-loop control 2
     *
     * This function is blocking. See 'single_turn_position_closed_loop_control_two_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result single_turn_position_closed_loop_control_two(SpinDirection direction, float angle_control, float max_speed) const;




        

    /**
     * @brief Callback type for subscribe_control_param.
     */
    using ControlParamCallback = std::function<void(ControlParamInformation)>;

    /**
     * @brief Handle type for subscribe_control_param.
     */
    using ControlParamHandle = Handle<ControlParamInformation>;

    /**
     * @brief Subscribe control parameters
     */
    ControlParamHandle subscribe_control_param(ControlParamType parameter_id, const ControlParamCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_control_param
     */
    void unsubscribe_control_param(ControlParamHandle handle);

        



    /**
     * @brief Poll for 'ControlParamInformation' (blocking).
     *
     * @return One ControlParamInformation update.
     */
    ControlParamInformation control_param(ControlParamType parameter_id) const;




    /**
     * @brief Write control parameters
     *
     * This function is non-blocking. See 'write_control_param' for the blocking counterpart.
     */
    void write_control_param_async(ControlParamInformation write_param, const ResultCallback callback);



    /**
     * @brief Write control parameters
     *
     * This function is blocking. See 'write_control_param_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result write_control_param(ControlParamInformation write_param) const;




        

    /**
     * @brief Callback type for subscribe_encode_position.
     */
    using EncodePositionCallback = std::function<void(EncodePosition)>;

    /**
     * @brief Handle type for subscribe_encode_position.
     */
    using EncodePositionHandle = Handle<EncodePosition>;

    /**
     * @brief Subscribe encoder current position
     */
    EncodePositionHandle subscribe_encode_position(const EncodePositionCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_encode_position
     */
    void unsubscribe_encode_position(EncodePositionHandle handle);

        



    /**
     * @brief Poll for 'EncodePosition' (blocking).
     *
     * @return One EncodePosition update.
     */
    EncodePosition encode_position() const;




    /**
    * @brief Callback type for set_encode_position_to_motor_zero_position_async.
    */
    using SetEncodePositionToMotorZeroPositionCallback = std::function<void(Result, uint32_t)>;

    /**
     * @brief Set current encoder position as motor zero
     *
     * This function is non-blocking. See 'set_encode_position_to_motor_zero_position' for the blocking counterpart.
     */
    void set_encode_position_to_motor_zero_position_async(const SetEncodePositionToMotorZeroPositionCallback callback);



    /**
     * @brief Set current encoder position as motor zero
     *
     * This function is blocking. See 'set_encode_position_to_motor_zero_position_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    std::pair<Result, uint32_t> set_encode_position_to_motor_zero_position() const;




        

    /**
     * @brief Callback type for subscribe_multi_turn_angles.
     */
    using MultiTurnAnglesCallback = std::function<void(float)>;

    /**
     * @brief Handle type for subscribe_multi_turn_angles.
     */
    using MultiTurnAnglesHandle = Handle<float>;

    /**
     * @brief Subscribe multi-turn angles
     */
    MultiTurnAnglesHandle subscribe_multi_turn_angles(const MultiTurnAnglesCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_multi_turn_angles
     */
    void unsubscribe_multi_turn_angles(MultiTurnAnglesHandle handle);

        



    /**
     * @brief Poll for 'float' (blocking).
     *
     * @return One float update.
     */
    float multi_turn_angles() const;




    /**
     * @brief Clear motor cycle count
     *
     * This function is non-blocking. See 'clear_motor_cycles' for the blocking counterpart.
     */
    void clear_motor_cycles_async(const ResultCallback callback);



    /**
     * @brief Clear motor cycle count
     *
     * This function is blocking. See 'clear_motor_cycles_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result clear_motor_cycles() const;




        

    /**
     * @brief Callback type for subscribe_single_turn_angles.
     */
    using SingleTurnAnglesCallback = std::function<void(float)>;

    /**
     * @brief Handle type for subscribe_single_turn_angles.
     */
    using SingleTurnAnglesHandle = Handle<float>;

    /**
     * @brief Subscribe single-turn angles
     */
    SingleTurnAnglesHandle subscribe_single_turn_angles(const SingleTurnAnglesCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_single_turn_angles
     */
    void unsubscribe_single_turn_angles(SingleTurnAnglesHandle handle);

        



    /**
     * @brief Poll for 'float' (blocking).
     *
     * @return One float update.
     */
    float single_turn_angles() const;




    /**
     * @brief Set current position as arbitrary angle
     *
     * This function is non-blocking. See 'set_cur_position_to_any_angle' for the blocking counterpart.
     */
    void set_cur_position_to_any_angle_async(const ResultCallback callback);



    /**
     * @brief Set current position as arbitrary angle
     *
     * This function is blocking. See 'set_cur_position_to_any_angle_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_cur_position_to_any_angle() const;




    /**
     * @brief motor flash save
     *
     * This function is non-blocking. See 'save_to_flash' for the blocking counterpart.
     */
    void save_to_flash_async(const ResultCallback callback);



    /**
     * @brief motor flash save
     *
     * This function is blocking. See 'save_to_flash_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result save_to_flash() const;




    /**
     * @brief motor calibration
     *
     * This function is non-blocking. See 'motor_calibration' for the blocking counterpart.
     */
    void motor_calibration_async(const ResultCallback callback);



    /**
     * @brief motor calibration
     *
     * This function is blocking. See 'motor_calibration_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result motor_calibration() const;




    /**
     * @brief set motor can id
     *
     * This function is non-blocking. See 'set_can_id' for the blocking counterpart.
     */
    void set_can_id_async(uint32_t can_id, const ResultCallback callback);



    /**
     * @brief set motor can id
     *
     * This function is blocking. See 'set_can_id_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_can_id(uint32_t can_id) const;




    /**
    * @brief Callback type for get_can_id_async.
    */
    using GetCanIdCallback = std::function<void(Result, uint32_t)>;

    /**
     * @brief set motor can id
     *
     * This function is non-blocking. See 'get_can_id' for the blocking counterpart.
     */
    void get_can_id_async(const GetCanIdCallback callback);



    /**
     * @brief set motor can id
     *
     * This function is blocking. See 'get_can_id_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    std::pair<Result, uint32_t> get_can_id() const;




    /**
     * @brief Motor reverse
     *
     * This function is non-blocking. See 'motor_force_reverse' for the blocking counterpart.
     */
    void motor_force_reverse_async(MotorForceReverse motor_force_reverse, const ResultCallback callback);



    /**
     * @brief Motor reverse
     *
     * This function is blocking. See 'motor_force_reverse_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result motor_force_reverse(MotorForceReverse motor_force_reverse) const;




    /**
     * @brief Angle reverse
     *
     * This function is non-blocking. See 'motor_angle_reverse' for the blocking counterpart.
     */
    void motor_angle_reverse_async(MotorAngleReverse motor_angle_reverse, const ResultCallback callback);



    /**
     * @brief Angle reverse
     *
     * This function is blocking. See 'motor_angle_reverse_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result motor_angle_reverse(MotorAngleReverse motor_angle_reverse) const;




    /**
     * @brief Line sequence reverse
     *
     * This function is non-blocking. See 'motor_line_reverse' for the blocking counterpart.
     */
    void motor_line_reverse_async(MotorLineReverse motor_line_reverse, const ResultCallback callback);



    /**
     * @brief Line sequence reverse
     *
     * This function is blocking. See 'motor_line_reverse_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result motor_line_reverse(MotorLineReverse motor_line_reverse) const;




    /**
     * @brief Zero calibration
     *
     * This function is non-blocking. See 'motor_zero_calibration' for the blocking counterpart.
     */
    void motor_zero_calibration_async(const ResultCallback callback);



    /**
     * @brief Zero calibration
     *
     * This function is blocking. See 'motor_zero_calibration_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result motor_zero_calibration() const;




    /**
     * @brief Motor driver model selection
     *
     * This function is non-blocking. See 'motor_select_drive' for the blocking counterpart.
     */
    void motor_select_drive_async(uint32_t driver_type, const ResultCallback callback);



    /**
     * @brief Motor driver model selection
     *
     * This function is blocking. See 'motor_select_drive_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result motor_select_drive(uint32_t driver_type) const;




    /**
     * @brief Motor enable/disable
     *
     * This function is non-blocking. See 'motor_enable' for the blocking counterpart.
     */
    void motor_enable_async(MotorEnable motor_enable, const ResultCallback callback);



    /**
     * @brief Motor enable/disable
     *
     * This function is blocking. See 'motor_enable_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result motor_enable(MotorEnable motor_enable) const;






    /**
     * @brief Select current motor .
     *
     * Bind the plugin instance to a specific motor_id
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result select_motor(int32_t motor_id) const;




    /**
     * @brief Copy constructor.
     */
    CustomMotor(const CustomMotor& other);

    /**
     * @brief Equality operator (object is not copyable).
     */
    const CustomMotor& operator=(const CustomMotor&) = delete;

private:
    /** @private Underlying implementation, set at instantiation */
    std::unique_ptr<CustomMotorImpl> _impl;
};

} // namespace mavsdk