// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/custom_gimbal/custom_gimbal.proto)

#pragma once

#include <array>
#include <cmath>
#include <functional>
#include <limits>
#include <memory>
#include <string>
#include <utility>
#include <vector>


#include "plugin_base.h"

#include "handle.h"

namespace mavsdk {


class System;class CustomGimbalImpl;

/**
 * @brief This service can be used to manage the MAVLink gimbal protocol.
 */
class CustomGimbal : public PluginBase {
public:

    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto custom_gimbal = CustomGimbal(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit CustomGimbal(System& system); // deprecated

    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto custom_gimbal = CustomGimbal(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit CustomGimbal(std::shared_ptr<System> system); // new


    /**
     * @brief Destructor (internal use only).
     */
    ~CustomGimbal() override;


    /**
     * @brief 
     */
    enum class GimbalMode {
        Lock, /**< @brief Lock mode. */
        YawFollow, /**< @brief Yaw follow mode. */
        Unknown, /**< @brief Unknown mode. */
    };

    /**
     * @brief Stream operator to print information about a `CustomGimbal::GimbalMode`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::GimbalMode const& gimbal_mode);

    /**
     * @brief 
     */
    enum class TkPeripheralDeviceStatusFlag {
        TkNoDeviceStatus, /**< @brief No valid peripheral device status. */
        TkVideoRecordingStatus, /**< @brief Camera zoom valid. */
        TkDeviceLaserLightStatus, /**< @brief Laser light status valid. */
        TkDeviceFillLightStatus, /**< @brief Fill light status valid. */
        TkDeviceLaserRangefinderStatus, /**< @brief Laser rangefinder status valid. */
        TkDeviceTargetRecognitionStatus, /**< @brief Target recognition status valid. */
        TkTriggerStatus, /**< @brief Trigger status valid. */
        TkElectricLockStatus, /**< @brief Electric lock status valid. */
    };

    /**
     * @brief Stream operator to print information about a `CustomGimbal::TkPeripheralDeviceStatusFlag`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::TkPeripheralDeviceStatusFlag const& tk_peripheral_device_status_flag);

    /**
     * @brief 
     */
    enum class TkTrackStatus {
        NotFound, /**< @brief Not found. */
        TempLost, /**< @brief Temporarily lost. */
        Tracking, /**< @brief Tracking. */
        Recovering, /**< @brief Recovering. */
    };

    /**
     * @brief Stream operator to print information about a `CustomGimbal::TkTrackStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::TkTrackStatus const& tk_track_status);

    /**
     * @brief 
     */
    enum class TkGimbalMode {
        Lock, /**< @brief Lock mode. */
        YawFollow, /**< @brief Yaw follow mode. */
        Unknown, /**< @brief Unknown mode. */
    };

    /**
     * @brief Stream operator to print information about a `CustomGimbal::TkGimbalMode`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::TkGimbalMode const& tk_gimbal_mode);

    /**
     * @brief 
     */
    enum class ImuConstantTemperature {
        Off, /**< @brief. */
        On, /**< @brief. */
    };

    /**
     * @brief Stream operator to print information about a `CustomGimbal::ImuConstantTemperature`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::ImuConstantTemperature const& imu_constant_temperature);




    /**
     * @brief 
     */
    struct PeripheralDeviceStatus {
        
        uint32_t camera_zoom{}; /**< @brief Camera zoom. */
        uint32_t laser_distance{}; /**< @brief Laser ranging distance, unit dm. */
        uint32_t photos_cnt{}; /**< @brief Photo count. */
        uint32_t status_flag{}; /**< @brief Peripheral device status flag, area see TK_PERIPHERAL_DEVICE_STATUS_FLAG. */
        uint32_t reserved{}; /**< @brief Reserved. */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::PeripheralDeviceStatus` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::PeripheralDeviceStatus& lhs, const CustomGimbal::PeripheralDeviceStatus& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::PeripheralDeviceStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::PeripheralDeviceStatus const& peripheral_device_status);




    /**
     * @brief 
     */
    struct InfraredTemperature {
        
        float infrared_temperature_max{}; /**< @brief Maximum infrared temperature, unit 0.1X */
        float infrared_temperature_min{}; /**< @brief Minimum infrared temperature, unit 0.1X */
        float infrared_temperature_avg{}; /**< @brief Average infrared temperature, unit 0.1X */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::InfraredTemperature` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::InfraredTemperature& lhs, const CustomGimbal::InfraredTemperature& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::InfraredTemperature`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::InfraredTemperature const& infrared_temperature);




    /**
     * @brief 
     */
    struct TrackingStatus {
        
        uint32_t status{}; /**< @brief Tracking status, area see GIMBAL_TRACKING_STATUS. */
        int32_t x_deviation_quantity{}; /**< @brief x-axis deviation amount, unit pixels, plus or minus 960 (image center as origin). */
        int32_t y_deviation_quantity{}; /**< @brief Y-axis deviation amount, unit pixels, plus or minus 540 (image center as origin). */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::TrackingStatus` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::TrackingStatus& lhs, const CustomGimbal::TrackingStatus& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::TrackingStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::TrackingStatus const& tracking_status);




    /**
     * @brief 
     */
    struct Attitude {
        
        uint32_t mode{}; /**< @brief Current mode area see TK_GIMBAL_MODE. */
        float pitch_angle{}; /**< @brief Pitch, unit degree. */
        float roll_angle{}; /**< @brief Roll, unit degree. */
        float yaw_angle{}; /**< @brief Yaw, unit degree. */
        float angular_velocity_x{}; /**< @brief Pitch angular velocity, unit degree per second. */
        float angular_velocity_y{}; /**< @brief Roll angular velocity, unit degree per second. */
        float angular_velocity_z{}; /**< @brief Yaw angular velocity, unit degree per second. */
        float acceleration_x{}; /**< @brief Pitch acceleration, unit degree per second squared. */
        float acceleration_y{}; /**< @brief Roll acceleration, unit degree per second squared. */
        float acceleration_z{}; /**< @brief Yaw acceleration, unit degree per second squared. */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::Attitude` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::Attitude& lhs, const CustomGimbal::Attitude& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::Attitude`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::Attitude const& attitude);




    /**
     * @brief 
     */
    struct GlobalPosition {
        
        int32_t longitude{}; /**< @brief Longitude, unit [degE7]. */
        int32_t latitude{}; /**< @brief Latitude, unit [degE7]. */
        int32_t altitude{}; /**< @brief Altitude, unit [mm]. */
        int32_t relative_altitude{}; /**< @brief Relative altitude, unit [mm]. */
        uint32_t heading{}; /**< @brief Heading, unit cdeg. */
        int32_t target_longitude{}; /**< @brief Target longitude, unit [degE7]. */
        int32_t target_latitude{}; /**< @brief Target latitude, unit [degE7]. */
        int32_t target_altitude{}; /**< @brief Target altitude, unit [mm]. */
        uint32_t target_distance{}; /**< @brief  Target horizontal distance, unit [dm]. */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::GlobalPosition` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::GlobalPosition& lhs, const CustomGimbal::GlobalPosition& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::GlobalPosition`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::GlobalPosition const& global_position);




    /**
     * @brief 
     */
    struct RcChannels {
        
        uint32_t chan1_raw{}; /**< @brief */
        uint32_t chan2_raw{}; /**< @brief */
        uint32_t chan3_raw{}; /**< @brief */
        uint32_t chan4_raw{}; /**< @brief */
        uint32_t chan5_raw{}; /**< @brief */
        uint32_t chan6_raw{}; /**< @brief */
        uint32_t chan7_raw{}; /**< @brief */
        uint32_t chan8_raw{}; /**< @brief */
        uint32_t chan9_raw{}; /**< @brief */
        uint32_t chan10_raw{}; /**< @brief */
        uint32_t chan11_raw{}; /**< @brief */
        uint32_t chan12_raw{}; /**< @brief */
        uint32_t chan13_raw{}; /**< @brief */
        uint32_t chan14_raw{}; /**< @brief */
        uint32_t chan15_raw{}; /**< @brief */
        uint32_t chan16_raw{}; /**< @brief */
        uint32_t chan17_raw{}; /**< @brief */
        uint32_t chan18_raw{}; /**< @brief */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::RcChannels` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::RcChannels& lhs, const CustomGimbal::RcChannels& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::RcChannels`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::RcChannels const& rc_channels);




    /**
     * @brief 
     */
    struct ImuInformation {
        
        float temperature{}; /**< @briefTemperature */
        float angular_velocity_x{}; /**< @briefAngular velocity X-axis */
        float angular_velocity_y{}; /**< @briefAngular velocity Y-axis */
        float angular_velocity_z{}; /**< @briefAngular velocity Z-axis */
        float acceleration_x{}; /**< @briefAcceleration X-axis */
        float acceleration_y{}; /**< @briefAcceleration Y-axis */
        float acceleration_z{}; /**< @briefAcceleration Z-axis */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::ImuInformation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::ImuInformation& lhs, const CustomGimbal::ImuInformation& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::ImuInformation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::ImuInformation const& imu_information);




    /**
     * @brief 
     */
    struct StdInformation {
        
        uint32_t gimbal_status_one{}; /**< @brief Gimbal status one */
        uint32_t gimbal_status_two{}; /**< @brief Gimbal status two */
        uint32_t gimbal_status_three{}; /**< @brief Gimbal status three */
        float pitch_frame_angle{}; /**< @brief Pitch frame angle, unit 0.1 degree */
        float yaw_frame_angle{}; /**< @brief Yaw frame angle, unit 0.1 degree */
        float roll_frame_angle{}; /**< @brief Roll frame angle, unit 0.1 degree */
        float x_deviation_quantity{}; /**< @brief X-axis deviation amount, unit pixels, plus or minus 960 (image center as origin) */
        float y_deviation_quantity{}; /**< @brief Y-axis deviation amount, unit pixels, plus or minus 540 (image center as origin) */
        float laser_distance{}; /**< @brief Laser ranging distance, unit dm */
        float zoom{}; /**< @brief Zoom ratio, unit 0.1X */
        double target_longitude{}; /**< @brief Target longitude, unit [degE7] */
        double target_latitude{}; /**< @brief Target latitude, unit [degE7] */
        double target_altitude{}; /**< @brief Target altitude, unit [dm] */
        uint32_t target_distance{}; /**< @brief Target horizontal distance, unit [dm] */
        double longitude{}; /**< @brief Aircraft longitude, unit [degE7] */
        double latitude{}; /**< @brief Aircraft latitude, unit [degE7] */
        double altitude{}; /**< @brief Aircraft altitude, unit [dm] */
        float infrared_temperature_max{}; /**< @brief Maximum infrared temperature, unit 0.1X */
        float infrared_temperature_min{}; /**< @brief Minimum infrared temperature, unit 0.1X */
        float infrared_temperature_avg{}; /**< @brief Average infrared temperature, unit 0.1X */
        float x_motor_angular_velocity{}; /**< @briefX-axis motor angular velocity, unit 0.1X. */
        float y_motor_angular_velocity{}; /**< @briefy-axis motor angular velocity, unit 0.1X. */
        float z_motor_angular_velocity{}; /**< @briefz-axis motor angular velocity, unit 0.1X. */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::StdInformation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::StdInformation& lhs, const CustomGimbal::StdInformation& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::StdInformation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::StdInformation const& std_information);




    /**
     * @brief 
     */
    struct LogInfo {
        
        uint32_t log_type{}; /**< @brief */
        uint32_t log_level{}; /**< @brief */
        std::string data{}; /**< @brief Actual data content, fixed to 128 bytes */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::LogInfo` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::LogInfo& lhs, const CustomGimbal::LogInfo& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::LogInfo`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::LogInfo const& log_info);




    /**
     * @brief 
     */
    struct ImuParameter {
        
        float temperature{}; /**< @brief Temperature */
        std::vector<float> gyro_offset{}; /**< @brief Gyroscope offset error, length should be 3 */
        std::vector<float> acc_norm{}; /**< @brief Accelerometer error, length should be 3 */
        std::vector<float> acc_matrix{}; /**< @brief Flattened 3x3 acceleration matrix, length is 9, stored in row-major order */
        uint32_t flag{}; /**< @brief Calibration completion flag */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::ImuParameter` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::ImuParameter& lhs, const CustomGimbal::ImuParameter& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::ImuParameter`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::ImuParameter const& imu_parameter);




    /**
     * @brief 
     */
    struct IpInfo {
        
        uint32_t ip_address{}; /**< @brief */
        uint32_t ip_port{}; /**< @brief */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::IpInfo` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::IpInfo& lhs, const CustomGimbal::IpInfo& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::IpInfo`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::IpInfo const& ip_info);




    /**
     * @brief Type to represent a speaker information.
     */
    struct Information {
        
        std::string vendor_name{}; /**< @brief Name of the speaker vendor */
        std::string model_name{}; /**< @brief Name of the speaker model */
        std::string serial_number{}; /**< @brief Serial number of the speaker */
        std::string firmware_version{}; /**< @brief Firmware version of the speaker */
        std::string protocol_version{}; /**< @brief protocol borad version */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::Information` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::Information& lhs, const CustomGimbal::Information& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::Information`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::Information const& information);




    /**
     * @brief 
     */
    struct CustomData {
        
        uint32_t message_id{}; /**< @brief Custom message ID */
        uint32_t len{}; /**< @brief */
        std::string data{}; /**< @brief Actual data content, fixed to 250 bytes */
    };

    /**
     * @brief Equal operator to compare two `CustomGimbal::CustomData` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const CustomGimbal::CustomData& lhs, const CustomGimbal::CustomData& rhs);

    /**
     * @brief Stream operator to print information about a `CustomGimbal::CustomData`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::CustomData const& custom_data);





    /**
     * @brief Possible results returned for gimbal commands.
     */
    enum class Result {
        Unknown, /**< @brief Unknown result. */
        Success, /**< @brief Command executed successfully. */
        InProgress, /**< @brief Command in progress. */
        Busy, /**< @brief Speaker is busy and rejected command. */
        Denied, /**< @brief Speaker denied the command. */
        Error, /**< @brief An error has occurred while executing the command. */
        Timeout, /**< @brief Command timed out. */
        WrongArgument, /**< @brief Command has wrong argument(s). */
        NoSystem, /**< @brief No system connected. */
        ProtocolUnsupported, /**< @brief Definition file protocol not supported. */
    };

    /**
     * @brief Stream operator to print information about a `CustomGimbal::Result`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, CustomGimbal::Result const& result);



    /**
     * @brief Callback type for asynchronous CustomGimbal calls.
     */
    using ResultCallback = std::function<void(Result)>;




    /**
     * @brief Prepare the custom_gimbal plugin (e.g. download the custom_gimbal definition, etc).
     *
     * This function is non-blocking. See 'prepare' for the blocking counterpart.
     */
    void prepare_async(const ResultCallback callback);



    /**
     * @brief Prepare the custom_gimbal plugin (e.g. download the custom_gimbal definition, etc).
     *
     * This function is blocking. See 'prepare_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result prepare() const;




    /**
     * @brief Send custom data to the gimbal.
     *
     * This allows sending arbitrary data with a custom message ID.
     *
     * This function is non-blocking.
     */
    void send_custom_data_async(CustomData custom_data, const ResultCallback callback);






        

    /**
     * @brief Callback type for subscribe_custom_data.
     */
    using CustomDataCallback = std::function<void(CustomData)>;

    /**
     * @brief Handle type for subscribe_custom_data.
     */
    using CustomDataHandle = Handle<CustomData>;

    /**
     * @brief 
     */
    CustomDataHandle subscribe_custom_data(CustomData custom_data, const CustomDataCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_custom_data
     */
    void unsubscribe_custom_data(CustomDataHandle handle);

        



    /**
     * @brief Poll for 'CustomData' (blocking).
     *
     * @return One CustomData update.
     */
    CustomData custom_data(CustomData custom_data) const;




    /**
     * @brief Enter Upgrade Mode
     *
     * This function is non-blocking. See 'enter_upgrade_mode' for the blocking counterpart.
     */
    void enter_upgrade_mode_async(const ResultCallback callback);



    /**
     * @brief Enter Upgrade Mode
     *
     * This function is blocking. See 'enter_upgrade_mode_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result enter_upgrade_mode() const;




    /**
     * @brief Exit Upgrade Mode
     *
     * This function is non-blocking. See 'exit_upgrade_mode' for the blocking counterpart.
     */
    void exit_upgrade_mode_async(const ResultCallback callback);



    /**
     * @brief Exit Upgrade Mode
     *
     * This function is blocking. See 'exit_upgrade_mode_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result exit_upgrade_mode() const;




        

    /**
     * @brief Callback type for subscribe_information.
     */
    using InformationCallback = std::function<void(Information)>;

    /**
     * @brief Handle type for subscribe_information.
     */
    using InformationHandle = Handle<Information>;

    /**
     * @brief Subscribe to gimbal information updates.
     */
    InformationHandle subscribe_information(const InformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_information
     */
    void unsubscribe_information(InformationHandle handle);

        



    /**
     * @brief Poll for 'Information' (blocking).
     *
     * @return One Information update.
     */
    Information information() const;




        

    /**
     * @brief Callback type for subscribe_ip_address.
     */
    using IpAddressCallback = std::function<void(IpInfo)>;

    /**
     * @brief Handle type for subscribe_ip_address.
     */
    using IpAddressHandle = Handle<IpInfo>;

    /**
     * @brief Query the IP address of the pod.
     */
    IpAddressHandle subscribe_ip_address(const IpAddressCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_ip_address
     */
    void unsubscribe_ip_address(IpAddressHandle handle);

        



    /**
     * @brief Poll for 'IpInfo' (blocking).
     *
     * @return One IpInfo update.
     */
    IpInfo ip_address() const;






    /**
     * @brief Select current gimbal .
     *
     * Bind the plugin instance to a specific gimbal_id
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result select_gimbal(int32_t gimbal_id) const;




    /**
     * @brief Turn on/off IMU constant temperature function
     *
     * This function is non-blocking. See 'is_open_imu_constant_temperature' for the blocking counterpart.
     */
    void is_open_imu_constant_temperature_async(ImuConstantTemperature status, const ResultCallback callback);



    /**
     * @brief Turn on/off IMU constant temperature function
     *
     * This function is blocking. See 'is_open_imu_constant_temperature_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result is_open_imu_constant_temperature(ImuConstantTemperature status) const;




    /**
     * @brief Set IMU constant temperature
     *
     * This function is non-blocking. See 'set_imu_temperature' for the blocking counterpart.
     */
    void set_imu_temperature_async(float temperature, const ResultCallback callback);



    /**
     * @brief Set IMU constant temperature
     *
     * This function is blocking. See 'set_imu_temperature_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_imu_temperature(float temperature) const;




    /**
     * @brief IMU level calibration
     *
     * This function is non-blocking. See 'imu_level_calibration' for the blocking counterpart.
     */
    void imu_level_calibration_async(const ResultCallback callback);



    /**
     * @brief IMU level calibration
     *
     * This function is blocking. See 'imu_level_calibration_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result imu_level_calibration() const;




    /**
     * @brief IMU orientation calibration
     *
     * This function is non-blocking. See 'imu_orientation_calibration' for the blocking counterpart.
     */
    void imu_orientation_calibration_async(int32_t x, int32_t y, int32_t z, const ResultCallback callback);



    /**
     * @brief IMU orientation calibration
     *
     * This function is blocking. See 'imu_orientation_calibration_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result imu_orientation_calibration(int32_t x, int32_t y, int32_t z) const;




    /**
     * @brief IMU  static calibration
     *
     * This function is non-blocking. See 'imu_static_calibration' for the blocking counterpart.
     */
    void imu_static_calibration_async(const ResultCallback callback);



    /**
     * @brief IMU  static calibration
     *
     * This function is blocking. See 'imu_static_calibration_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result imu_static_calibration() const;




    /**
     * @brief Save IMU parameters
     *
     * This function is non-blocking. See 'save_imu_parameter' for the blocking counterpart.
     */
    void save_imu_parameter_async(const ResultCallback callback);



    /**
     * @brief Save IMU parameters
     *
     * This function is blocking. See 'save_imu_parameter_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result save_imu_parameter() const;




        

    /**
     * @brief Callback type for subscribe_imu_parameter.
     */
    using ImuParameterCallback = std::function<void(ImuParameter)>;

    /**
     * @brief Handle type for subscribe_imu_parameter.
     */
    using ImuParameterHandle = Handle<ImuParameter>;

    /**
     * @brief Subscribe IMU parameters
     */
    ImuParameterHandle subscribe_imu_parameter(const ImuParameterCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_imu_parameter
     */
    void unsubscribe_imu_parameter(ImuParameterHandle handle);

        



    /**
     * @brief Poll for 'ImuParameter' (blocking).
     *
     * @return One ImuParameter update.
     */
    ImuParameter imu_parameter() const;




        

    /**
     * @brief Callback type for subscribe_log_info.
     */
    using LogInfoCallback = std::function<void(LogInfo)>;

    /**
     * @brief Handle type for subscribe_log_info.
     */
    using LogInfoHandle = Handle<LogInfo>;

    /**
     * @brief Subscribe log info
     */
    LogInfoHandle subscribe_log_info(const LogInfoCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_log_info
     */
    void unsubscribe_log_info(LogInfoHandle handle);

        



    /**
     * @brief Poll for 'LogInfo' (blocking).
     *
     * @return One LogInfo update.
     */
    LogInfo log_info() const;




        

    /**
     * @brief Callback type for subscribe_imu_parameters.
     */
    using ImuParametersCallback = std::function<void(ImuParameter)>;

    /**
     * @brief Handle type for subscribe_imu_parameters.
     */
    using ImuParametersHandle = Handle<ImuParameter>;

    /**
     * @brief Subscribe IMU parameters
     */
    ImuParametersHandle subscribe_imu_parameters(const ImuParametersCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_imu_parameters
     */
    void unsubscribe_imu_parameters(ImuParametersHandle handle);

        



    /**
     * @brief Poll for 'ImuParameter' (blocking).
     *
     * @return One ImuParameter update.
     */
    ImuParameter imu_parameters() const;




        

    /**
     * @brief Callback type for subscribe_imu_info.
     */
    using ImuInfoCallback = std::function<void(ImuInformation)>;

    /**
     * @brief Handle type for subscribe_imu_info.
     */
    using ImuInfoHandle = Handle<ImuInformation>;

    /**
     * @brief Subscribe IMU info, including IMU temperature, three-axis angular velocity, three-axis acceleration
     */
    ImuInfoHandle subscribe_imu_info(const ImuInfoCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_imu_info
     */
    void unsubscribe_imu_info(ImuInfoHandle handle);

        



    /**
     * @brief Poll for 'ImuInformation' (blocking).
     *
     * @return One ImuInformation update.
     */
    ImuInformation imu_info() const;




        

    /**
     * @brief Callback type for subscribe_std_info.
     */
    using StdInfoCallback = std::function<void(StdInformation)>;

    /**
     * @brief Handle type for subscribe_std_info.
     */
    using StdInfoHandle = Handle<StdInformation>;

    /**
     * @brief Subscribe to standard messages feedback from gimbal to user
     */
    StdInfoHandle subscribe_std_info(const StdInfoCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_std_info
     */
    void unsubscribe_std_info(StdInfoHandle handle);

        



    /**
     * @brief Poll for 'StdInformation' (blocking).
     *
     * @return One StdInformation update.
     */
    StdInformation std_info() const;




        

    /**
     * @brief Callback type for subscribe_rc_channels.
     */
    using RcChannelsCallback = std::function<void(RcChannels)>;

    /**
     * @brief Handle type for subscribe_rc_channels.
     */
    using RcChannelsHandle = Handle<RcChannels>;

    /**
     * @brief Subscribe to standard messages feedback from gimbal to user
     */
    RcChannelsHandle subscribe_rc_channels(const RcChannelsCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_rc_channels
     */
    void unsubscribe_rc_channels(RcChannelsHandle handle);

        



    /**
     * @brief Poll for 'RcChannels' (blocking).
     *
     * @return One RcChannels update.
     */
    RcChannels rc_channels() const;




        

    /**
     * @brief Callback type for subscribe_global_position.
     */
    using GlobalPositionCallback = std::function<void(GlobalPosition)>;

    /**
     * @brief Handle type for subscribe_global_position.
     */
    using GlobalPositionHandle = Handle<GlobalPosition>;

    /**
     * @brief subscribe global position
     */
    GlobalPositionHandle subscribe_global_position(const GlobalPositionCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_global_position
     */
    void unsubscribe_global_position(GlobalPositionHandle handle);

        



    /**
     * @brief Poll for 'GlobalPosition' (blocking).
     *
     * @return One GlobalPosition update.
     */
    GlobalPosition global_position() const;




        

    /**
     * @brief Callback type for subscribe_attitude.
     */
    using AttitudeCallback = std::function<void(Attitude)>;

    /**
     * @brief Handle type for subscribe_attitude.
     */
    using AttitudeHandle = Handle<Attitude>;

    /**
     * @brief subscribe attitude
     */
    AttitudeHandle subscribe_attitude(const AttitudeCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_attitude
     */
    void unsubscribe_attitude(AttitudeHandle handle);

        



    /**
     * @brief Poll for 'Attitude' (blocking).
     *
     * @return One Attitude update.
     */
    Attitude attitude() const;




        

    /**
     * @brief Callback type for subscribe_tracking_status.
     */
    using TrackingStatusCallback = std::function<void(TrackingStatus)>;

    /**
     * @brief Handle type for subscribe_tracking_status.
     */
    using TrackingStatusHandle = Handle<TrackingStatus>;

    /**
     * @brief subscribe tracking status
     */
    TrackingStatusHandle subscribe_tracking_status(const TrackingStatusCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_tracking_status
     */
    void unsubscribe_tracking_status(TrackingStatusHandle handle);

        



    /**
     * @brief Poll for 'TrackingStatus' (blocking).
     *
     * @return One TrackingStatus update.
     */
    TrackingStatus tracking_status() const;




        

    /**
     * @brief Callback type for subscribe_infrared_temperature.
     */
    using InfraredTemperatureCallback = std::function<void(InfraredTemperature)>;

    /**
     * @brief Handle type for subscribe_infrared_temperature.
     */
    using InfraredTemperatureHandle = Handle<InfraredTemperature>;

    /**
     * @brief subscribe infrared temperature
     */
    InfraredTemperatureHandle subscribe_infrared_temperature(const InfraredTemperatureCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_infrared_temperature
     */
    void unsubscribe_infrared_temperature(InfraredTemperatureHandle handle);

        



    /**
     * @brief Poll for 'InfraredTemperature' (blocking).
     *
     * @return One InfraredTemperature update.
     */
    InfraredTemperature infrared_temperature() const;




        

    /**
     * @brief Callback type for subscribe_peripheral_device_status.
     */
    using PeripheralDeviceStatusCallback = std::function<void(PeripheralDeviceStatus)>;

    /**
     * @brief Handle type for subscribe_peripheral_device_status.
     */
    using PeripheralDeviceStatusHandle = Handle<PeripheralDeviceStatus>;

    /**
     * @brief subscribe peripheral device status
     */
    PeripheralDeviceStatusHandle subscribe_peripheral_device_status(const PeripheralDeviceStatusCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_peripheral_device_status
     */
    void unsubscribe_peripheral_device_status(PeripheralDeviceStatusHandle handle);

        



    /**
     * @brief Poll for 'PeripheralDeviceStatus' (blocking).
     *
     * @return One PeripheralDeviceStatus update.
     */
    PeripheralDeviceStatus peripheral_device_status() const;




    /**
     * @brief gimbal mode setting
     *
     * This function is non-blocking. See 'set_gimbal_mode' for the blocking counterpart.
     */
    void set_gimbal_mode_async(GimbalMode mode, const ResultCallback callback);



    /**
     * @brief gimbal mode setting
     *
     * This function is blocking. See 'set_gimbal_mode_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_gimbal_mode(GimbalMode mode) const;




    /**
     * @brief Copy constructor.
     */
    CustomGimbal(const CustomGimbal& other);

    /**
     * @brief Equality operator (object is not copyable).
     */
    const CustomGimbal& operator=(const CustomGimbal&) = delete;

private:
    /** @private Underlying implementation, set at instantiation */
    std::unique_ptr<CustomGimbalImpl> _impl;
};

} // namespace mavsdk