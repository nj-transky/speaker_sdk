// WARNING: THIS FILE IS AUTOGENERATED! As such, it should not be edited.
// Edits need to be made to the proto files
// (see https://github.com/mavlink/MAVSDK-Proto/blob/main/protos/speaker/speaker.proto)

#pragma once

#include <array>
#include <cmath>
#include <functional>
#include <limits>
#include <memory>
#include <string>
#include <utility>
#include <vector>


#include "plugin_base.h"

#include "handle.h"

namespace mavsdk {


class System;class SpeakerImpl;

/**
 * @brief Can be used to manage speakers that implement the MAVLink
 * Speaker Protocol: .
 *
 * Currently only a single speaker is supported.
 * When multiple speakers are supported the plugin will need to be
 * instantiated separately for every speaker and the speaker selected using
 * `select_speaker`.
 */
class Speaker : public PluginBase {
public:

    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto speaker = Speaker(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit Speaker(System& system); // deprecated

    /**
     * @brief Constructor. Creates the plugin for a specific System.
     *
     * The plugin is typically created as shown below:
     *
     *     ```cpp
     *     auto speaker = Speaker(system);
     *     ```
     *
     * @param system The specific system associated with this plugin.
     */
    explicit Speaker(std::shared_ptr<System> system); // new


    /**
     * @brief Destructor (internal use only).
     */
    ~Speaker() override;


    /**
     * @brief File update type.
     */
    enum class FileUpdateType {
        None, /**< @brief Unknown file update type. */
        Add, /**< @brief File added. */
        Remove, /**< @brief File deleted. */
        Rename, /**< @brief File renamed. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::FileUpdateType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::FileUpdateType const& file_update_type);

    /**
     * @brief Audios range type.
     */
    enum class AudiosRange {
        All, /**< @brief All the audios present on the speaker. */
        SinceConnection, /**< @brief Audios recorded since MAVSDK got connected. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::AudiosRange`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::AudiosRange const& audios_range);

    /**
     * @brief 
     */
    enum class PlayMode {
        None, /**< @brief None play mode. */
        SinglePlay, /**< @brief Play a audio once. */
        LoopPlay, /**< @brief Loop play a audio. */
        RealTimeSpeak, /**< @brief Real time speak play mode. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::PlayMode`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::PlayMode const& play_mode);

    /**
     * @brief 
     */
    enum class PlayStatus {
        Idle, /**< @brief Not play any audio. */
        Playing, /**< @brief Play a audio. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::PlayStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::PlayStatus const& play_status);

    /**
     * @brief Light mode type.
     */
    enum class LightMode {
        ModeUnknown, /**< @brief Unknown light mode. */
        Mode1, /**< @brief Light mode 1. */
        Mode2, /**< @brief Light mode 2. */
        Mode3, /**< @brief Light mode 3. */
        Mode4, /**< @brief Light mode 4. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::LightMode`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::LightMode const& light_mode);

    /**
     * @brief Switch on/off type.
     */
    enum class SwitchOnOff {
        Off, /**< @brief off. */
        On, /**< @brief on. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::SwitchOnOff`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::SwitchOnOff const& switch_on_off);

    /**
     * @brief 
     */
    enum class RealTimeVoiceStatus {
        VoiceOff, /**< @brief Real time voice off. */
        VoiceOn, /**< @brief Real time voice on. */
        VoiceError, /**< @brief Real time voice error. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::RealTimeVoiceStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::RealTimeVoiceStatus const& real_time_voice_status);

    /**
     * @brief Multi Connection Operation type.
     */
    enum class OperationType {
        MultiConnectionOpen, /**< @brief Connection open. */
        MultiConnectionClose, /**< @brief Connection close. */
        MultiConnectionRemove, /**< @brief Connection remove. */
        MultiConnectionAdd, /**< @brief Connection add. */
        MultiConnectionQueryAmount, /**< @brief Connection query amount. */
        MultiConnectionQueryId, /**< @brief Connection query ID. */
        MultiConnectionQueryStatus, /**< @brief Connection query status. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::OperationType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::OperationType const& operation_type);

    /**
     * @brief 
     */
    enum class FileOperationPermission {
        Release, /**< @brief Release file operation permission. */
        Get, /**< @brief Get file operation permission. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::FileOperationPermission`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::FileOperationPermission const& file_operation_permission);

    /**
     * @brief 
     */
    enum class RealTimeVoiceOperation {
        StartRealTimeListen, /**< @brief Start real time voice listen. */
        StopRealTimeListen, /**< @brief Stop real time voice listen. */
        StartRealTimeSpeak, /**< @brief Start real time voice speak. */
        StopRealTimeSpeak, /**< @brief Stop real time voice speak. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::RealTimeVoiceOperation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::RealTimeVoiceOperation const& real_time_voice_operation);

    /**
     * @brief log level
     */
    enum class LogLevel {
        Debug, /**< @brief Debug log level. */
        Info, /**< @brief Info log level. */
        Warning, /**< @brief Warning log level. */
        Error, /**< @brief Error log level. */
        Fatal, /**< @brief Fatal log level. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::LogLevel`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::LogLevel const& log_level);





    /**
     * @brief Possible results returned for speaker commands
     */
    enum class Result {
        Unknown, /**< @brief Unknown result. */
        Success, /**< @brief Command executed successfully. */
        InProgress, /**< @brief Command in progress. */
        Busy, /**< @brief Speaker is busy and rejected command. */
        Denied, /**< @brief Speaker denied the command. */
        Error, /**< @brief An error has occurred while executing the command. */
        Timeout, /**< @brief Command timed out. */
        WrongArgument, /**< @brief Command has wrong argument(s). */
        NoSystem, /**< @brief No system connected. */
        ProtocolUnsupported, /**< @brief Definition file protocol not supported. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::Result`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::Result const& result);





    /**
     * @brief Information about a audio.
     */
    struct AudioInfo {
        
        std::string name{}; /**< @brief The name of audio file */
        uint32_t index{}; /**< @brief Zero-based index of this audio since vehicle was armed */
        std::string format{}; /**< @brief Audio file's format */
        float length{}; /**< @brief The length of audio (in secends) */
    };

    /**
     * @brief Equal operator to compare two `Speaker::AudioInfo` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::AudioInfo& lhs, const Speaker::AudioInfo& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::AudioInfo`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::AudioInfo const& audio_info);




    /**
     * @brief Type to represent a speaker information.
     */
    struct Information {
        
        std::string vendor_name{}; /**< @brief Name of the speaker vendor */
        std::string model_name{}; /**< @brief Name of the speaker model */
        std::string serial_number{}; /**< @brief Serial number of the speaker */
        std::string firmware_version{}; /**< @brief Firmware version of the speaker */
    };

    /**
     * @brief Equal operator to compare two `Speaker::Information` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::Information& lhs, const Speaker::Information& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::Information`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::Information const& information);




    /**
     * @brief 
     */
    struct Angle {
        
        float roll{}; /**< @brief Roll value */
        float pitch{}; /**< @brief Pitch value */
        float yaw{}; /**< @brief Yaw value */
    };

    /**
     * @brief Equal operator to compare two `Speaker::Angle` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::Angle& lhs, const Speaker::Angle& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::Angle`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::Angle const& angle);




    /**
     * @brief Information about the speaker status.
     */
    struct Status {
        
        PlayMode play_mode{}; /**< @brief Play audio mode */
        PlayStatus play_status{}; /**< @brief Whether audio playing is currently in process */
        float playing_time_s{}; /**< @brief Elapsed time since starting the audio playing (in seconds) */
        float current_volume{}; /**< @brief Current volume level (in persentage) */
        int32_t network_module_signal_quality{}; /**< @brief Network module signal quality (in percentage) */
        float network_module_latency_ms{}; /**< @brief Network module latency (in milliseconds) */
        Angle angle{}; /**< @brief Angle value */
        LightMode light_mode{}; /**< @brief Light mode */
        SwitchOnOff light_on_off{}; /**< @brief Light on/off */
        RealTimeVoiceStatus real_time_listen_status{}; /**< @brief Real time listen status */
        RealTimeVoiceStatus real_time_speak_status{}; /**< @brief Real time speak status */
    };

    /**
     * @brief Equal operator to compare two `Speaker::Status` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::Status& lhs, const Speaker::Status& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::Status`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::Status const& status);






    /**
     * @brief Information about the speaker storage.
     */
    struct StorageInformation {
        
        /**
     * @brief Storage status type.
     */
    enum class StorageStatus {
        NotAvailable, /**< @brief Storage not available. */
        Unformatted, /**< @brief Storage is not formatted (i.e. has no recognized file system). */
        Formatted, /**< @brief Storage is formatted (i.e. has recognized a file system). */
        NotSupported, /**< @brief Storage status is not supported. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::StorageStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::StorageInformation::StorageStatus const& storage_status);
        
        /**
     * @brief Storage type.
     */
    enum class StorageType {
        Unknown, /**< @brief Storage type unknown. */
        UsbStick, /**< @brief Storage type USB stick. */
        Sd, /**< @brief Storage type SD card. */
        Microsd, /**< @brief Storage type MicroSD card. */
        Hd, /**< @brief Storage type HD mass storage. */
        Other, /**< @brief Storage type other, not listed. */
    };

    /**
     * @brief Stream operator to print information about a `Speaker::StorageType`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::StorageInformation::StorageType const& storage_type);
        
        StorageStatus storage_status{}; /**< @brief Storage status */
        StorageType storage_type{}; /**< @brief Storage type */
        float total_storage_mib{}; /**< @brief Total storage (in MiB) */
        float used_storage_mib{}; /**< @brief Used storage (in MiB) */
        float available_storage_mib{}; /**< @brief Available storage (in MiB) */
    };

    /**
     * @brief Equal operator to compare two `Speaker::StorageInformation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::StorageInformation& lhs, const Speaker::StorageInformation& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::StorageInformation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::StorageInformation const& storage_information);




    /**
     * @brief Type to represent a setting option.
     */
    struct Option {
        
        std::string option_id{}; /**< @brief Name of the option (machine readable) */
        std::string option_description{}; /**< @brief Description of the option (human readable) */
    };

    /**
     * @brief Equal operator to compare two `Speaker::Option` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::Option& lhs, const Speaker::Option& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::Option`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::Option const& option);




    /**
     * @brief Type to represent a setting with a selected option.
     */
    struct Setting {
        
        std::string setting_id{}; /**< @brief Name of a setting (machine readable) */
        std::string setting_description{}; /**< @brief Description of the setting (human readable). This field is meant to be read from the drone, ignore it when setting. */
        Option option{}; /**< @brief Selected option */
        bool is_range{}; /**< @brief If option is given as a range. This field is meant to be read from the drone, ignore it when setting. */
    };

    /**
     * @brief Equal operator to compare two `Speaker::Setting` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::Setting& lhs, const Speaker::Setting& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::Setting`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::Setting const& setting);




    /**
     * @brief Type to represent a setting with a list of options to choose from.
     */
    struct SettingOptions {
        
        std::string setting_id{}; /**< @brief Name of the setting (machine readable) */
        std::string setting_description{}; /**< @brief Description of the setting (human readable) */
        std::vector<Option> options{}; /**< @brief List of options or if range [min, max] or [min, max, interval] */
        bool is_range{}; /**< @brief If option is given as a range */
    };

    /**
     * @brief Equal operator to compare two `Speaker::SettingOptions` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::SettingOptions& lhs, const Speaker::SettingOptions& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::SettingOptions`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::SettingOptions const& setting_options);




    /**
     * @brief 
     */
    struct MultiConnectionOperation {
        
        OperationType operation_type{}; /**< @brief Multi connection operation type */
        uint64_t connection_id{}; /**< @brief Connection ID */
        uint32_t connection_index{}; /**< @brief Connection index */
    };

    /**
     * @brief Equal operator to compare two `Speaker::MultiConnectionOperation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::MultiConnectionOperation& lhs, const Speaker::MultiConnectionOperation& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::MultiConnectionOperation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::MultiConnectionOperation const& multi_connection_operation);




    /**
     * @brief 
     */
    struct MultiConnectionStatus {
        
        OperationType operation_ack{}; /**< @brief Multi connection operation ack */
        uint32_t connection_amount{}; /**< @brief Connection amount */
        uint32_t connection_index{}; /**< @brief Connection index */
        uint64_t connection_id{}; /**< @brief Connection ID */
        bool connection_status{}; /**< @brief Connection status */
    };

    /**
     * @brief Equal operator to compare two `Speaker::MultiConnectionStatus` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::MultiConnectionStatus& lhs, const Speaker::MultiConnectionStatus& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::MultiConnectionStatus`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::MultiConnectionStatus const& multi_connection_status);




    /**
     * @brief 
     */
    struct LogInformation {
        
        std::string text{}; /**< @brief Log message text */
        LogLevel log_level{}; /**< @brief Log level of the message */
    };

    /**
     * @brief Equal operator to compare two `Speaker::LogInformation` objects.
     *
     * @return `true` if items are equal.
     */
    friend bool operator==(const Speaker::LogInformation& lhs, const Speaker::LogInformation& rhs);

    /**
     * @brief Stream operator to print information about a `Speaker::LogInformation`.
     *
     * @return A reference to the stream.
     */
    friend std::ostream& operator<<(std::ostream& str, Speaker::LogInformation const& log_information);


    /**
     * @brief Callback type for asynchronous Speaker calls.
     */
    using ResultCallback = std::function<void(Result)>;




    /**
     * @brief Prepare the speaker plugin (e.g. download the speaker definition, etc).
     *
     * This function is non-blocking. See 'prepare' for the blocking counterpart.
     */
    void prepare_async(const ResultCallback callback);



    /**
     * @brief Prepare the speaker plugin (e.g. download the speaker definition, etc).
     *
     * This function is blocking. See 'prepare_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result prepare() const;




    /**
     * @brief Notify audio files updated.
     *
     * This function is non-blocking. See 'notify_audio_file_update' for the blocking counterpart.
     */
    void notify_audio_file_update_async(FileUpdateType update_type, const ResultCallback callback);



    /**
     * @brief Notify audio files updated.
     *
     * This function is blocking. See 'notify_audio_file_update_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result notify_audio_file_update(FileUpdateType update_type) const;




    /**
     * @brief Start single play audio.
     *
     * This function is non-blocking. See 'start_play_audio_single' for the blocking counterpart.
     */
    void start_play_audio_single_async(uint32_t index, const ResultCallback callback);



    /**
     * @brief Start single play audio.
     *
     * This function is blocking. See 'start_play_audio_single_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result start_play_audio_single(uint32_t index) const;




    /**
     * @brief Start loop play audio.
     *
     * This function is non-blocking. See 'start_play_audio_loop' for the blocking counterpart.
     */
    void start_play_audio_loop_async(uint32_t index, const ResultCallback callback);



    /**
     * @brief Start loop play audio.
     *
     * This function is blocking. See 'start_play_audio_loop_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result start_play_audio_loop(uint32_t index) const;




    /**
     * @brief Start play audio.
     *
     * This function is non-blocking. See 'stop_play_audio' for the blocking counterpart.
     */
    void stop_play_audio_async(const ResultCallback callback);



    /**
     * @brief Start play audio.
     *
     * This function is blocking. See 'stop_play_audio_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result stop_play_audio() const;




    /**
     * @brief Set speaker volume.
     *
     * This function is non-blocking. See 'set_volume' for the blocking counterpart.
     */
    void set_volume_async(uint32_t volume, const ResultCallback callback);



    /**
     * @brief Set speaker volume.
     *
     * This function is blocking. See 'set_volume_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_volume(uint32_t volume) const;




        

    /**
     * @brief Callback type for subscribe_audio_info.
     */
    using AudioInfoCallback = std::function<void(AudioInfo)>;

    /**
     * @brief Handle type for subscribe_audio_info.
     */
    using AudioInfoHandle = Handle<AudioInfo>;

    /**
     * @brief Subscribe to audio file information.
     */
    AudioInfoHandle subscribe_audio_info(std::string audio_name, const AudioInfoCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_audio_info
     */
    void unsubscribe_audio_info(AudioInfoHandle handle);

        



    /**
     * @brief Poll for 'AudioInfo' (blocking).
     *
     * @return One AudioInfo update.
     */
    AudioInfo audio_info(std::string audio_name) const;




        

    /**
     * @brief Callback type for subscribe_information.
     */
    using InformationCallback = std::function<void(Information)>;

    /**
     * @brief Handle type for subscribe_information.
     */
    using InformationHandle = Handle<Information>;

    /**
     * @brief Subscribe to speaker information updates.
     */
    InformationHandle subscribe_information(const InformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_information
     */
    void unsubscribe_information(InformationHandle handle);

        



    /**
     * @brief Poll for 'Information' (blocking).
     *
     * @return One Information update.
     */
    Information information() const;




        

    /**
     * @brief Callback type for subscribe_status.
     */
    using StatusCallback = std::function<void(Status)>;

    /**
     * @brief Handle type for subscribe_status.
     */
    using StatusHandle = Handle<Status>;

    /**
     * @brief Subscribe to speaker status updates.
     */
    StatusHandle subscribe_status(const StatusCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_status
     */
    void unsubscribe_status(StatusHandle handle);

        



    /**
     * @brief Poll for 'Status' (blocking).
     *
     * @return One Status update.
     */
    Status status() const;




        

    /**
     * @brief Callback type for subscribe_storage_information.
     */
    using StorageInformationCallback = std::function<void(StorageInformation)>;

    /**
     * @brief Handle type for subscribe_storage_information.
     */
    using StorageInformationHandle = Handle<StorageInformation>;

    /**
     * @brief Subscribe to speaker status updates.
     */
    StorageInformationHandle subscribe_storage_information(const StorageInformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_storage_information
     */
    void unsubscribe_storage_information(StorageInformationHandle handle);

        



    /**
     * @brief Poll for 'StorageInformation' (blocking).
     *
     * @return One StorageInformation update.
     */
    StorageInformation storage_information() const;




        

    /**
     * @brief Callback type for subscribe_current_settings.
     */
    using CurrentSettingsCallback = std::function<void(std::vector<Setting>)>;

    /**
     * @brief Handle type for subscribe_current_settings.
     */
    using CurrentSettingsHandle = Handle<std::vector<Setting>>;

    /**
     * @brief Get the list of current speaker settings.
     */
    CurrentSettingsHandle subscribe_current_settings(const CurrentSettingsCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_current_settings
     */
    void unsubscribe_current_settings(CurrentSettingsHandle handle);

        






        

    /**
     * @brief Callback type for subscribe_possible_setting_options.
     */
    using PossibleSettingOptionsCallback = std::function<void(std::vector<SettingOptions>)>;

    /**
     * @brief Handle type for subscribe_possible_setting_options.
     */
    using PossibleSettingOptionsHandle = Handle<std::vector<SettingOptions>>;

    /**
     * @brief Get the list of settings that can be changed.
     */
    PossibleSettingOptionsHandle subscribe_possible_setting_options(const PossibleSettingOptionsCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_possible_setting_options
     */
    void unsubscribe_possible_setting_options(PossibleSettingOptionsHandle handle);

        



    /**
     * @brief Poll for 'std::vector<SettingOptions>' (blocking).
     *
     * @return One std::vector<SettingOptions> update.
     */
    std::vector<SettingOptions> possible_setting_options() const;




    /**
     * @brief Set a setting to some value.
     *
     * Only setting_id of setting and option_id of option needs to be set.
     *
     * This function is non-blocking. See 'set_setting' for the blocking counterpart.
     */
    void set_setting_async(Setting setting, const ResultCallback callback);



    /**
     * @brief Set a setting to some value.
     *
     * Only setting_id of setting and option_id of option needs to be set.
     *
     * This function is blocking. See 'set_setting_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_setting(Setting setting) const;




    /**
    * @brief Callback type for get_setting_async.
    */
    using GetSettingCallback = std::function<void(Result, Setting)>;

    /**
     * @brief Get a setting.
     *
     * Only setting_id of setting needs to be set.
     *
     * This function is non-blocking. See 'get_setting' for the blocking counterpart.
     */
    void get_setting_async(Setting setting, const GetSettingCallback callback);



    /**
     * @brief Get a setting.
     *
     * Only setting_id of setting needs to be set.
     *
     * This function is blocking. See 'get_setting_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    std::pair<Result, Speaker::Setting> get_setting(Setting setting) const;




    /**
     * @brief Reset all settings in speaker.
     *
     * This will reset all speaker settings to default value
     *
     * This function is non-blocking. See 'reset_settings' for the blocking counterpart.
     */
    void reset_settings_async(const ResultCallback callback);



    /**
     * @brief Reset all settings in speaker.
     *
     * This will reset all speaker settings to default value
     *
     * This function is blocking. See 'reset_settings_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result reset_settings() const;




    /**
     * @brief Format storage (e.g. SD card) in speaker.
     *
     * This will delete all content of the speaker storage!
     *
     * This function is non-blocking. See 'format_storage' for the blocking counterpart.
     */
    void format_storage_async(const ResultCallback callback);



    /**
     * @brief Format storage (e.g. SD card) in speaker.
     *
     * This will delete all content of the speaker storage!
     *
     * This function is blocking. See 'format_storage_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result format_storage() const;






    /**
     * @brief Select current speaker .
     *
     * Bind the plugin instance to a specific Speaker_id
     *
     * This function is blocking.
     *
     * @return Result of request.
     */
    Result select_speaker(int32_t speaker_id) const;




    /**
     * @brief Update the firmware of the speaker.
     *
     * This function is non-blocking. See 'update_firmware' for the blocking counterpart.
     */
    void update_firmware_async(const ResultCallback callback);



    /**
     * @brief Update the firmware of the speaker.
     *
     * This function is blocking. See 'update_firmware_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result update_firmware() const;




    /**
     * @brief Restart the speaker plugin.
     *
     * This function is non-blocking. See 'restart' for the blocking counterpart.
     */
    void restart_async(const ResultCallback callback);



    /**
     * @brief Restart the speaker plugin.
     *
     * This function is blocking. See 'restart_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result restart() const;




    /**
     * @brief Speaker angle control.
     *
     * This function is non-blocking. See 'set_angle' for the blocking counterpart.
     */
    void set_angle_async(Angle angle, const ResultCallback callback);



    /**
     * @brief Speaker angle control.
     *
     * This function is blocking. See 'set_angle_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_angle(Angle angle) const;




    /**
     * @brief Set light mode.
     *
     * This function is non-blocking. See 'set_light_mode' for the blocking counterpart.
     */
    void set_light_mode_async(LightMode light_mode, const ResultCallback callback);



    /**
     * @brief Set light mode.
     *
     * This function is blocking. See 'set_light_mode_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_light_mode(LightMode light_mode) const;




    /**
     * @brief Turn on/off light.
     *
     * This function is non-blocking. See 'set_light_on_off' for the blocking counterpart.
     */
    void set_light_on_off_async(SwitchOnOff light_on_off, const ResultCallback callback);



    /**
     * @brief Turn on/off light.
     *
     * This function is blocking. See 'set_light_on_off_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result set_light_on_off(SwitchOnOff light_on_off) const;




    /**
     * @brief Follow the gimbal.
     *
     * This function is non-blocking. See 'follow_gimbal' for the blocking counterpart.
     */
    void follow_gimbal_async(SwitchOnOff follow_gimbal, const ResultCallback callback);



    /**
     * @brief Follow the gimbal.
     *
     * This function is blocking. See 'follow_gimbal_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result follow_gimbal(SwitchOnOff follow_gimbal) const;




    /**
     * @brief Multi Connection Operation
     *
     * This function is non-blocking. See 'multi_connection_operation' for the blocking counterpart.
     */
    void multi_connection_operation_async(MultiConnectionOperation operation, const ResultCallback callback);



    /**
     * @brief Multi Connection Operation
     *
     * This function is blocking. See 'multi_connection_operation_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result multi_connection_operation(MultiConnectionOperation operation) const;




        

    /**
     * @brief Callback type for subscribe_multi_connection_amount.
     */
    using MultiConnectionAmountCallback = std::function<void(uint32_t)>;

    /**
     * @brief Handle type for subscribe_multi_connection_amount.
     */
    using MultiConnectionAmountHandle = Handle<uint32_t>;

    /**
     * @brief Subscribe to multi connection amount.
     */
    MultiConnectionAmountHandle subscribe_multi_connection_amount(const MultiConnectionAmountCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_multi_connection_amount
     */
    void unsubscribe_multi_connection_amount(MultiConnectionAmountHandle handle);

        



    /**
     * @brief Poll for 'uint32_t' (blocking).
     *
     * @return One uint32_t update.
     */
    uint32_t multi_connection_amount() const;




        

    /**
     * @brief Callback type for subscribe_multi_connection_id.
     */
    using MultiConnectionIdCallback = std::function<void(uint64_t)>;

    /**
     * @brief Handle type for subscribe_multi_connection_id.
     */
    using MultiConnectionIdHandle = Handle<uint64_t>;

    /**
     * @brief Subscribe to multi connection id by index.
     */
    MultiConnectionIdHandle subscribe_multi_connection_id(uint32_t index, const MultiConnectionIdCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_multi_connection_id
     */
    void unsubscribe_multi_connection_id(MultiConnectionIdHandle handle);

        



    /**
     * @brief Poll for 'uint64_t' (blocking).
     *
     * @return One uint64_t update.
     */
    uint64_t multi_connection_id(uint32_t index) const;




        

    /**
     * @brief Callback type for subscribe_multi_connection_status.
     */
    using MultiConnectionStatusCallback = std::function<void(MultiConnectionStatus)>;

    /**
     * @brief Handle type for subscribe_multi_connection_status.
     */
    using MultiConnectionStatusHandle = Handle<MultiConnectionStatus>;

    /**
     * @brief Query connection status.
     */
    MultiConnectionStatusHandle subscribe_multi_connection_status(uint64_t connection_id, const MultiConnectionStatusCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_multi_connection_status
     */
    void unsubscribe_multi_connection_status(MultiConnectionStatusHandle handle);

        



    /**
     * @brief Poll for 'MultiConnectionStatus' (blocking).
     *
     * @return One MultiConnectionStatus update.
     */
    MultiConnectionStatus multi_connection_status(uint64_t connection_id) const;




    /**
     * @brief Apply file operation permission.
     *
     * This function is non-blocking. See 'apply_file_operation_permission' for the blocking counterpart.
     */
    void apply_file_operation_permission_async(FileOperationPermission permission, const ResultCallback callback);



    /**
     * @brief Apply file operation permission.
     *
     * This function is blocking. See 'apply_file_operation_permission_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result apply_file_operation_permission(FileOperationPermission permission) const;




    /**
     * @brief Real time voice operation permission.
     *
     * This function is non-blocking. See 'real_time_voice_operation' for the blocking counterpart.
     */
    void real_time_voice_operation_async(RealTimeVoiceOperation operation, const ResultCallback callback);



    /**
     * @brief Real time voice operation permission.
     *
     * This function is blocking. See 'real_time_voice_operation_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result real_time_voice_operation(RealTimeVoiceOperation operation) const;




    /**
     * @brief Enter developer mode
     *
     * This function is non-blocking. See 'enter_dev_mode' for the blocking counterpart.
     */
    void enter_dev_mode_async(std::string pwd, const ResultCallback callback);



    /**
     * @brief Enter developer mode
     *
     * This function is blocking. See 'enter_dev_mode_async' for the non-blocking counterpart.
     *
     * @return Result of request.
     */
    Result enter_dev_mode(std::string pwd) const;




        

    /**
     * @brief Callback type for subscribe_log_information.
     */
    using LogInformationCallback = std::function<void(LogInformation)>;

    /**
     * @brief Handle type for subscribe_log_information.
     */
    using LogInformationHandle = Handle<LogInformation>;

    /**
     * @brief Get server log information
     */
    LogInformationHandle subscribe_log_information(const LogInformationCallback& callback);

    /**
     * @brief Unsubscribe from subscribe_log_information
     */
    void unsubscribe_log_information(LogInformationHandle handle);

        






    /**
     * @brief Copy constructor.
     */
    Speaker(const Speaker& other);

    /**
     * @brief Equality operator (object is not copyable).
     */
    const Speaker& operator=(const Speaker&) = delete;

private:
    /** @private Underlying implementation, set at instantiation */
    std::unique_ptr<SpeakerImpl> _impl;
};

} // namespace mavsdk